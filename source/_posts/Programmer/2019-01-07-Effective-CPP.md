## 从 C 转向 C++。
C 是一种简单的语言。它真正提供的只有有宏、指针、结构、数组和函数。不管什么问题,C 都靠宏、指针、结构、数组和函数来解决。而 C++不是这样。

- 条款 1 : 尽量用`const`和`inline`而不用`#define`。
解释：意义在于尽量用编译器而不用预处理。宏定义导致符号在编译阶段根本看不到，因为符号都被预处理替换为对应的值了。宏定义可以简单的用常量来替换。除此之外，用宏来实现函数的效果也不是好的做法，直接用类型模板的内联函数可以实现同样的效果，好处是可预计的行为和类型安全。因为用了类型模板，为了方式大的拷贝构造，可以直接返回引用。

- 条款 2 : 尽量用`<iostream>`而不用`<stdio.h>`
解释：`scanf`和`printf`不是类型安全的,而且没有扩展性，而类型安全和扩展性是 C++ 的基石。`iostream`在极少数情况会有一些弊端，现在甚至完全可以不用考虑。另外`<iostream.h>`不推荐用，这个头文件不提供名字空间，或者是说将同样的内容置于全局空间中。

- 条款 3 : 尽量用`new`和`delete`而不用`malloc`和`free`
解释：`malloc`和`free`(及其变体)会产生问题的原因在于它们太简单:他们不知道构造函数和析构函数。即`malloc`一块空间真的仅仅是开辟一块空间，而`new`则会在这块空间内放上构造好的对象。`free`和`delete`同理，前者会释放内存但是不析构对象，如果对象内有动态申请的内存就会导致内存泄漏。而且二者也不要混用，`new`的用`delete`释放，`malloc`用`free`释放。所以既然这么复杂，最好就是一心一意的用`new`和`delete`。

- 条款 4 : 尽量使用 C++ 风格的注释
解释：C++的行尾注释法是特有的，有的 C 编译器不支持这种注释。而且 C 注释在嵌套的时候会有问题。

## 内存管理
C++中涉及到的内存的管理问题可以归结为两方面:正确地得到它和有效地使用它。

- 条款 5 : 对应的`new`和`delete`要采用相同的形式
解释：指的是是否带上中括号来表示操作的是单个对象还是一个数组，有没有中括号意味着执行一次还是多次构造或者析构函数。如果不匹配的用，结果将是未定义的。这也使得该条款要求最好杜绝对数组类型用`typedef`，因为`new`一个新类型没有问题，但是在`delete`时这个类型时要求要加上中括号，这很容易忘。作为替代，用`vector`。

- 条款 6 : 析构函数里对指针成员调用`delete`
解释：删除空指针是安全的(因为它什么也没做)。所以,在写构造函数，赋值操作符,或其他成员函数时,保证**类的每个指针成员要么指向有效的内存，要么就指向空**,那在你的析构函数里你就可以只用简单地`delete`掉他们,而不用担心他们是不是被`new`过。

- 条款 7 : 预先准备好内存不够的情况
