---
layout: post
date: 2017-7-1
title: 形式语言与自动机基础
category: 数学
tags: maths
keywords:
description:
---

> *数学表达式支持来自于[MathJax](http://mathjax-chinese-doc.readthedocs.io/en/latest/start.html)，如果渲染失败，刷新一下试试。使用latex公式语法。[快速查询](http://zh.numberempire.com/texequationeditor/equationeditor.php)*

# **基本概念**

### 形式语法

形式语法是一个4元组 G=(N, \\(\Sigma\\) P, S), 其中：

- N 是非终结符的有限集合(有时也叫变量集或句法种类集);
- \\(\Sigma\\)是终结符的有限集合,\\(\Sigma\\)和N的交集为空且\\(\Sigma\\)和N的并集;称总词汇表;
- P是一组重写规则的有限集合:P={\\(\alpha \rightarrow \beta\\)},其中,\\(\alpha\\)和\\(\beta\\)是 V 中元素构成的串,但\\(\alpha\\)中至少应含有一个非终结符号;
- S\\(\in\\)N,称为句子符或初始符。




### 句型和句子
一些特殊类型的符号串为文法 G=(N,\\(\Sigma\\) , P, S) 的句子形式(句型),采取递归的方式定义：

1. S 是一个句子形式;
2. 如果\\(\alpha\\)\\(\beta\\)\\(\gamma\\)是一个句子形式,且\\(\beta\rightarrow\delta\\)是 P 的产生式,则\\(\alpha\\)\\(\delta\\)\\(\gamma\\)也是一个句子形式;

文法 G 的不含非终结符的句子形式称为 G 生成的句子。由文法 G 生成的语言,记作 L(G),指 G 生成的所有句子的集合。

### 正则文法
如果文法 G=(N,\\(\Sigma\\) , P, S) 的 P 中的规则满足如下形式:

> A\\(\rightarrow\\)Bx, 或 A\\(\rightarrow\\)x, 其中 A, B \\(\in\\) N, x\\(\in\\)\\(\Sigma\\),则

称该文法为正则文法或称3型文法。(左线性正则文法)
如果 A\\(\rightarrow\\)xB,则该文法称为右线性正则文法。
<!-- more -->

若 G 是一个正则文法, 则存在一个有限自动机nfa,使得:T(M) = L(G)。

### 上下文无关文法(context-free grammar, CFG)
如果 P 中的规则满足如下形式:

> A\\(\rightarrow\alpha\\), 其中A\\(\in\\)N, \\(\alpha\\)\\(\in\\)所有文法的闭包

则称该文法为上下文无关文法(CFG) 或称 2 型文法。




### 语言与自动机的对应关系

|  语言类型  |      | 识别器类型  |
|---|----|----|
|0型||图灵机|
|1型||线性带限自动机|
|2型||下推自动机|
|3型||有限自动机|

各类自动机的主要区别是它们能够使用的信息存储空间的差异:

- 有限状态自动机只能用状态来存储信息;
- 下推自动机除了可以用状态以外,还可以用下推存储器(栈);
- 线性带限自动机可以利用状态和输入/输出带本身。因为输入/输出带没有“先进后出”的限制,因此,其功能大于栈;
- 而图灵机的存储空间没有任何限制。


### 确定型又穷自动机（dfa）
定义为一个五元组\\(M_D = (Q_D,\Sigma,\delta_D,{q_0},F\_D)\\)，其中：

- Q是内部状态（internal state）的有限集合；
- \\(\Sigma\\)是符号的有限集合，叫做输入字母表（input alphabet）；
- \\(M_D = (Q_D × \Sigma \rightarrow Q\_D\\)是一个全函数，叫转移函数（transition function）；
- \\(q\_0 \in Q\\)是初态（initial state）；
- \\(F \subseteq Q\\)是终态（final state）集合。

### 正则语言

如果一种语言能够被一个有穷自动接受器接受，那么这种语言就是正则语言。正则语言可以通过枚举法，描述法，正则表达式或者有限自动接收器表示。

# **算法**

### nfa转换为dfa（P42）

> 定理：设L是被非确定型有穷接收器\\(M_N=(Q_N,\Sigma,\delta_N,q_0,F_N)\\)，接受的语言。那么一定存在一个确定型有穷接收器\\(M_D = (Q_D,\Sigma,\delta_D,{q_0},F_D)\\)，满足：L=L\\(M_D\\)。

具体算法：

1. 从顶点{q0}开始构造确定有限自动机的图\\(G\_N\\)，把这个顶点看做起始顶点。
2. 重复下面的步骤，直到没有边被漏掉：
3. 取\\(G\_N\\)的一个顶点node1 = {\\(q\_i\\)，\\(q\_j\\)，..., \\(G\_k\\)}，该顶点目前还没有标记为\\(a\in\Sigma\\)的输出边。计算node1中所有顶点在nfa中接受a之后的状态集合作为dfa的顶点node2。如果node2还不存在，则新增，在node1和node2之间新增边标记为a。
4. 对于\\(G\_D\\)中的每一个包含输入nfa中的终态的新的状态，在dfa中标记为终态。
5. 如果nfa接受\\(\lambda\\)，那么新的dfa中的\\(q\_0\\)也是终态。

### dfa化简

> 可以证明，花键之后的状态机M是**最小的**，这里的最小指的是它是所有接受L(M)的dfa中状态数最少的。

首先通过mark算法标记所有的可区分状态对。然后通过reduce算法合并所有的不可区分状态对，完成简化。

mark算法：

1. 去掉所有的不可达状态。通过列举dfa图中的所有起点为初态的简单** 通道 **，就可以完成这一点，人和不再这种通道上的都是不可达状态。
2. 考察所有的状态对(p,q), 如果p\\(\in\\)F并且q\\(\notin\\)F，或者反之，把状态对(p,q)标记为可区分。
3. 对于所有的状态对(p,q)和所有的a\\(\in\Sigma\\)，计算其转移状态对(\\(p_a,q_a\\))，如果状态对(\\(p_a,q_a\\))被标记为可区分，那么状态对(p,q)也标记为可区分，重复这个过程直到所有状态对都完成标记。
4. 注：逆向标记，宽度优先遍历。

这个过程完成之后可以把所有的状态对标记为可区分或不可区分，由于不可区分是一种等价关系，具有传递性，所以不可区分关系可以完成对状态的划分。

reduce算法：
1. 对每一不可区分状态构成的集合创建一个新的状态，根据状态转移函数，在新的状态之间创建状态转移函数，如果mark算法执行正确，在这一步不会产生歧义（即一个不可区分集合中的所有状态接受一个输入后得到的转移状态应该属于同一个不可区分集合）。
2. 包含原初态的标记为初态，包含原终态的标记为终态。

### 正则语言与正则表达式之间的转换

> 定理：设r是正则表达式。那么一定存在一个非确定性有穷接收器接受L(r)。因此，L(r)是正则语言。

> 定理：设L是正则语言，那么总存在正则表达式r使得L=L(r)

解读：

- 对于每一个正则语言，都可以找到一个正则表达式表达它。而每一种正则表达式也都对应一种正则语言。而其中转换的桥梁就是自动机。
- 正向的说，对于每一个正则表达式，我们都可以构造一个与之对应的nfa，而这个nfa可以表示为正则文法（左/右线性文法），即正则语言。正则表达式构造nfa通过自底向上的方式构造，然后转化为dfa，然后根据状态转移函数生成右线性文法中的重写规则。
- 反向的说，通过正则文法中的重写规则构造转移函数，通过变量构造nfa的状态，通过终结符构造转移函数的输入。然后利用消解法构造消除dfa中的可消状态，最后规约为基本形式得到正则表达式。
