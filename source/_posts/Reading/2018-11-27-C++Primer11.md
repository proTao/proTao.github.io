---
layout: post
date: 2018-11-27 15:23:51
title: 《C++Primer》第十一章：关联容器
category: 读书笔记
tags:
- reading
- C++
keywords:
description:
---


1. 使用`map`容器下标操作时，如果键还没有在容器中，则容器会默认创建一个新元素。如果不希望默认创建新元素，就使用`find`方法，返回迭代器，没有指定元素时，迭代器指向尾后元素。注意对于map来说，下标得到的结果是`mapped_type`类型，find得到的结果是迭代器，迭代器指向的类型是`value_type`。另外，set和multimap、unordered_multimap没有下标操作。
2. map中的元素是`pair`类型的对象，迭代器也是只想这样的对象。数据成员名为`first`和`second`。
3. 关联容器的迭代器都是双向迭代器，不是随机寻址迭代器。
4. 对于有序容器的关键字类型的限制：关键字类型必须定义元素比较的方法，严格的说是**严格弱序**，可以看作小于号。如果自定义类型上没有定义小于号，那么在构造函数中需要传入一个作为比较方法的函数指针。
5. pair类型定义在标准库`utility`中。

<!-- more -->

6. 一个`map`的`value_type`是一个`pair`，可以改变pair的值，不可以改变关键字成员的值。`set`的迭代器也有`iterator`和`const_iterator`两种，两种实际上都是const的，原因在于set的关键字本身不能改变。对于关键字不可变这一点很好理解，类似于python中的字典对象一定要使用不可变类型一样。
7. 通常不对关联容器使用搜索算法，原因有二。其一，对于类似于`replace`或者`sort`这种算法，需要写元素，但是关联容器的键是const的，不可写，所以不能应用。其二、对于`find`这类的只读算法，关联容器自身提供`find`成员函数，通过键直接获取元素，而泛型算法中的`find`却会顺序搜索，因此不推荐用。
8. 不重复的关联容器`insert`或者`emplace`单一元素的时候，方法的返回值是一个pair，first是一个迭代器，指向插入元素，second是一个布尔值，表示是否插入成功。允许重复的容器就仅仅返回一个迭代器，因为一定插入成功。
9. 关联容器的`erase`有三个重载过的版本，其中两个与顺序容器的一致，接受一个迭代器或者迭代器范围，返回迭代器。关联容器提供一个额外的erase接受一个键类型的对象作为参数，返回值是int，表示被删除的元素的数量。
10. 如果关心的是是否存在的问题，那么对于不允许重复的关联容器，`find`和`count`没有什么区别，但是对于允许重复关键字的容器，conut顾名思义还会统计个数，，不需要计数的时候推荐使用find。
11. 对于允许重复关键字的容器，如果多个元素有相同的键，则这些元素在容器中会相邻存储，即使是无序容器。因此可以使用find和conut拿到所有元素，因为find返回指向第一个元素的迭代器。第二种方法是使用`lower_bound`和`upper_bound`前者指向第一个具有关键字的元素，后者指向最后一个匹配的元素的后面的位置。如果元素不存在，`lower_bound`返回的迭代器指向关键字的安全插入点————不影响容器中元素顺序的插入位置。第三种方法是使用`equal_range`，返回值是一个迭代器pair，这个pair存放的就是上下界。
12. `unordered_multimap`没有`at`和下标操作符，因为存在潜在的重复元素。
13. 无序关联容器是基于哈希的。
