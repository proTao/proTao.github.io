1. c++11 推荐使用列表初始化。
2. 声明规定了变量的类型和名字，定义还申请存储空间，并可能执行初始化操作。声明操作需要关键字`extern`，并且不要显式初始化变量。对变量初始化会抵消extern的作用，而且函数体内部，初始化extern变量甚至会报错。
3. 自定义标识符不能连续出现两个下划线，也不能以下划线紧接大写字母开头。函数体外的标识符不能以下划线开头。
4. 名字的作用域始于名字的声明语句，结束于语句所在的作用域末端。
5. 使用`::a`访问全局作用域中的a。
6. 引用为对象起了另外一个名字。对于引用，一旦初始化完成，引用和其对象将一直绑定，因此必须初始化。另外，引用不是一个对象，因此不能建立引用的引用。
7. 指针与引用有几个不同：指针本身就是对象；指针指向的对象可以改变；可以不初始化，但是会未定义。
8. C++11推荐使用`nullptr`。
9. `void*`是一种特殊的指针类型，可以存放任意对象的地址。看起来很强大，但实际上约束很多，只可以用于指针比较，作为函数的输入输出，或者复制给另外的void
*指针。因为我们不知道他是什么类型的指针，也就无法确定可以进行什么操作。
10. 对于复杂的声明符，从右向左阅读更好理解，比如`int *&p`首先是一个引用，引用的是指针类型，该指针指向int类型。
11. 类似于引用，const对象不能改变，因此const对象必须初始化。编译器会在编译过程中直接对const变量替换成它的值，通常const对象的作用域是自身文件。如果希望文件之间共享，那么需要extern关键字（只需要在一个文件中初始化值）。
12. 想要引用常量对象，必须使用const修饰引用。被const修饰的引用有些特殊，可以绑定到非const对象甚至字面量身上。
13. `const int* p`中p可以指向不同的对象，但是不可以通过p修改其指向的对象。`int *const p`中，p自身不能变。诀窍还是从右向左看。顶层const表示指针本身是常量，顶层const表示指针所指的对象是一个常量。
14. 常量表达式是指值不会改变而且在编译过程中就可以求值的表达式。显然字面量是常量表达式，用常量表达式初始化的const对象也是常量表达式。如果你认定一个变量是常量表达式，那么就是用constexpr关键字。声明constexpr的类型限制为算数类型、引用、指针还有一些其他比较少见的情况。如将要将引用或者指针声明为constexpr，初始值必须是nullptr，或者存储于固定地址的对象（通常指函数体之外定义的对象）。
15. 对于类型别名，新标准规定了新的方法，使用`using`关键字。注意使用类型别名的声明语句千万不要把类型变回去理解。如下面的例子，cstr应该是一个常量指针，但是如果变回去看，就变成了一个指向常量字符的普通指针。
```CPP
typedef char *pstring;
const pstring cstr = 0;
//const char* cstr = 0;
```
16. `auto`类型说明符可以让编译器自动推断类型，必须要有初始值。`auto`会自动忽略顶层const。
17. 当希望使用一个表达式的类型类声明一个新变量的时候，使用`decltype`关键字。例如`decltype(f()) sum=x;`使用f的返回值类型声明新变量。不同于auto，该关键字会保留引用、顶层const等性质。（通常引用等价于被绑定的变量不予区分，但是如果decltype一个引用，那么我们得到的还是一个引用。注意，使用双层括号时，得到的类型一定是引用。


