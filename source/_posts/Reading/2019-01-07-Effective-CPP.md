## 从 C 转向 C++。
C 是一种简单的语言。它真正提供的只有有宏、指针、结构、数组和函数。不管什么问题,C 都靠宏、指针、结构、数组和函数来解决。而 C++不是这样。

- 条款 1 : 尽量用`const`和`inline`而不用`#define`。
解释：意义在于尽量用编译器而不用预处理。宏定义导致符号在编译阶段根本看不到，因为符号都被预处理替换为对应的值了。宏定义可以简单的用常量来替换。除此之外，用宏来实现函数的效果也不是好的做法，直接用类型模板的内联函数可以实现同样的效果，好处是可预计的行为和类型安全。因为用了类型模板，为了方式大的拷贝构造，可以直接返回引用。

- 条款 2 : 尽量用`<iostream>`而不用`<stdio.h>`
解释：`scanf`和`printf`不是类型安全的,而且没有扩展性，而类型安全和扩展性是 C++ 的基石。`iostream`在极少数情况会有一些弊端，现在甚至完全可以不用考虑。另外`<iostream.h>`不推荐用，这个头文件不提供名字空间，或者是说将同样的内容置于全局空间中。

- 条款 3 : 尽量用`new`和`delete`而不用`malloc`和`free`
解释：`malloc`和`free`(及其变体)会产生问题的原因在于它们太简单:他们不知道构造函数和析构函数。即`malloc`一块空间真的仅仅是开辟一块空间，而`new`则会在这块空间内放上构造好的对象。`free`和`delete`同理，前者会释放内存但是不析构对象，如果对象内有动态申请的内存就会导致内存泄漏。而且二者也不要混用，`new`的用`delete`释放，`malloc`用`free`释放。所以既然这么复杂，最好就是一心一意的用`new`和`delete`。

- 条款 4 : 尽量使用 C++ 风格的注释
解释：C++的行尾注释法是特有的，有的 C 编译器不支持这种注释。而且 C 注释在嵌套的时候会有问题。

## 内存管理
C++中涉及到的内存的管理问题可以归结为两方面:正确地得到它和有效地使用它。

- 条款 5 : 对应的`new`和`delete`要采用相同的形式
解释：指的是是否带上中括号来表示操作的是单个对象还是一个数组，有没有中括号意味着执行一次还是多次构造或者析构函数。如果不匹配的用，结果将是未定义的。这也使得该条款要求最好杜绝对数组类型用`typedef`，因为`new`一个新类型没有问题，但是在`delete`时这个类型时要求要加上中括号，这很容易忘。作为替代，用`vector`。

- 条款 6 : 析构函数里对指针成员调用`delete`
解释：删除空指针是安全的(因为它什么也没做)。所以,在写构造函数，赋值操作符,或其他成员函数时,保证**类的每个指针成员要么指向有效的内存，要么就指向空**,那在你的析构函数里你就可以只用简单地`delete`掉他们,而不用担心他们是不是被`new`过。


- 条款 7 : 预先准备好内存不够的情况 [class]
解释：1993 年前, C++ 一直要求在内存分配失败时的`new`要返回 0,现在则是要求`new`抛出`std::bad_alloc`异常。为了兼容，新的 C++ 也提供无抛出的方式，即`new (nothrow)`。我们可以为了防止内存申请失败，用 trycatch 块包裹代码。但是更好的方式是使用`new`头文件中的`set_new_handler`来设置`new`失败时的回调函数。C++不支持专门针对于类的`new-handler`函数,而且也不需要。你可以自己来实现它,只要在每个类中提供自己版本的`set_new_handler`和`operator new`。也不用每个类都这么干，可以写一个简单的混入类作为基类。作为`new_handler`必须完成这几件事之一：得到了更多的可用内存;安装了一个新的`new-handler`(出错处理函数);卸除了`new-handler`;抛出了一个`std::bad_alloc`或其派生类型的异常;或者返回失败。

- 条款 8 : 写`operator new`和`operator delete`时要遵循常规 [class]
解释：自己重写`operator new`时(条款 10 解释了为什么有时要重写它),很重要的一点是函数提供的行为要和系统缺省的`operator new`一致。实际做起来也就是:要有正确的返回值;可用内存不够时要调用出错处理函数(见条款 7);处理好 0 字节内存请求的情况。此外,还要避免不小心隐藏了标准形式的 new,不过这是条款 9 的话题。因为`new`操作中存在 while 循环，要想跳出循环，要么执行回调函数并产生条款 7 中的效果，要么内存分配成功。另外，零字节的`new`调用可以直接转化为1字节的`new`调用。因此， 空类即什么都没有的类，照理说大小应该是0，但是，空类的大小为1。

- 条款 9 : 避免隐藏标准形式的`new`

- 条款 10 : 如果写了`operator new`就要同时写`operator delete` [class]
解释：为什么有必要写自己的`new`和`delete`? 答案通常是:为了效率。缺省的`operator new`和`operator delete`具有非常好的通用性,它的这种灵活性也使得在某些特定的场合下,可以进一步改善它的性能。尤其在那些需要动态分配大量的但很小的对象的应用程序里,情况更是如此。考虑缺省的内存操作：`new`必须可以分配任意大小的内存块。同样,`operator delete`也要可以释放任意大小的内存块。`operator delete`想弄清它要释放的内存有多大,就必须知道当初`operator new`分配的内存有多大。有一种常用的方法可以让`operator new`来告诉`operator delete`当初分配的内存大小是多少,就是在它所返回的内存里预先附带一些额外信息,用来指明被分配的内存块的大小。对于很小的对象来说,这些额外的数据信息会使得动态分配对象时所需要的的内存的大小翻番(特别是类里没有虚拟函数的时候)。
这一部分内容较多，介绍了小对象内存池的方法以及内存池类的抽象。


## 构造函数,析构函数和赋值操作符
在这些函数上出错就会给整个类带来无尽的负面影响,所以一定要保证其正确性。

- 条款 11 : 为需要动态分配内存的类声明一个拷贝构造函数和一个赋值操作符
解释：对于有些类,当实现拷贝构造函数和赋值操作符非常麻烦的时候,特别是可以确信程序中不会做拷贝和赋值操作的时候,去实现它们就会相对来说有点得不偿失。该怎么办呢? 很简单,照本条款的建议去做:可以只声明这些函数(声明为 private 成员)而不去定义(实现)它们。这就防止了会有人去调用它们,也防止了编译器去生成它们。

- 条款 12 : 尽量使用初始化而不要在构造函数里赋值
解释：从纯实际应用的角度来看,有些情况下必须用初始化。特别是`const`和引用数据成员只能用初始化,不能被赋值。通过成员初始化列表来进行初始化总是合法的,效率也决不低于在构造函数体内赋值,它只会更高效。另外,它简化了对类的维护(见条款M32),因为如果一个数据成员以后被修改成了必须使用成员初始化列表的某种数据类型,那么,什么也不用变。但有一种情况下,对类的数据成员用赋值比用初始化更合理。这就是当有大量的固定类型的数据成员要在每个构造函数里以相同的方式初始化的时候。

- 条款 13 : 初始化列表中成员列出的顺序和它们在类中声明的顺序相同
解释：记住这一点很简单，但是原因是什么呢？。我们知道,对一个对象的所有成员来说,它们的析构函数被调用的顺序总是和它们在构造函数里被创建的顺序相反。确保按照被声明的顺序来初始化使得析构函数不需记住构造函数的构造顺序。另外,基类数据成员总是在派生类数据成员之前被初始化,所以使用继承时,要把基类的初始化列在成员初始化列表的最前面。最后，(如果使用多继承,基类被初始化的顺序和它们被派生类继承的顺序一致,它们在成员初始化列表中的顺序会被忽略。

- 条款 14: 确定基类有虚析构函数
C++语言标准关于这个问题的阐述非常清楚:当通过基类的指针去删除派生类的对象,而基类又没有虚析构函数时,结果将是不可确定的。(实际运行时经常发生的是,派生类的析构函数永远不会被调用。)为了避免这个问题,只需要使基类的析构函数为 virtual。声明析构函数为虚就会带来你所希望的运行良好的行为:对象内存释放时, 基类和派生类的析构函数都会被调用。虚析构函数工作的方式是:最底层的派生类的析构函数最先被调用,然后各个基类的析构函数被调用。

- 条款 15: 让 operator=返回*this 的引用
`operator=`的返回值必须可以作为一个输入参数被函数自己接受。一个常犯的错误是让 operator=返回一个 const 对象的引用。

- 条款 16: 在 operator=中对所有数据成员赋值
解释：初写这个类时当然很容易记住上面的原则,但同样重要的是,当类里增加新的数据成员时,也要记住更新赋值运算符函数。当涉及到继承时,情况就会更有趣,因为派生类的赋值运算符也必须处理它的基类成员的赋值!


- 条款 17: 在 operator=中检查给自己赋值的情况
解释：当一个对象有很多别名的时候，很可能出现自己对自己赋值的行为。而这种行为的危险性在于：一个赋值运算符必须首先释放掉一个对象的资源(去掉旧值),然后根据新值分配新的资源。在自己给自己赋值的情况下,释放旧的资源将是灾难性的,因为在分配新的资源时会需要旧的资源。在赋值运算符中要特别注意可能出现别名的情况,其理由基于两点。其中之一是效率。如果可以在赋值运算符函数体的首部检测到是给自己赋值,就可以立即返回,从而可以节省大量的工作,否则必须去实现整个赋值操作。例如, 条款 16 指出,一个正确的派生类的赋值运算符必须调用它的每个基类的的赋值运算符,所以在派生类中省略赋值运算符函数体的操作将会避免大量对其他函数的调用。

## 类和函数:设计与声明
在程序中声明一个新类将导致产生一种新的类型: 类的设计就是类型设计。设计一个好的类很具有挑战性,因为设计好的类型很具有挑战性。好的类型具有自然的语法,直观的语义和高效的实现。对象将如何被创建和摧毁?它将极大地影响构造函数和析构函数的设计,以及自定义的`operator new`,`operator new[]`,`operator delete`, 和 `operator delete[]`。对象初始化和对象赋值有什么不同? 答案决定了构造函数和赋值运算符的行为以及它们之间的区别。通过值来传递新类型的对象意味着什么? 拷贝函数负责对此做出回答。允许哪种类型转换? 如果允许类型 A 的对象隐式转换为类型 B 的对象,就要在类 A 中写一个类型转换函数,或者,在类 B 中写一个可以用单个参数来调用的非 explicit 构造函数。

- 条款 18: 争取使类的接口完整并且最小
类的用户接口是指使用这个类的程序员所能访问得到的接口。典型的接口里只有函数存在,因为在用户接口里放上数据成员会有很多缺点(见条款 20)。无端地在接口里增加函数不是没有代价的,所以在增加一个新函数时要仔细考虑:它所带来的方便性(只有在接口完整的前提下才应该考虑增加一个新函数以提供方便性)是否超过它所带来的额外代价,如复杂性,可读性,可维护性和编译时间等。如果有的操作可以简单地被其他的操作组合得到，那么这个操作就不是最小的。

- 条款 19: 分清成员函数,非成员函数和友元函数
解释：成员函数和非成员函数最大的区别在于成员函数可以是虚拟的而非成员函数不行。只要能避免使用友元函数就要避免, 因为,和现实生活中差不多,友元(朋友)带来的麻烦往往比它(他/她)对你的帮助多。

- 条款 20: 避免 public 接口出现数据成员
解释：首先,从“一致性”的角度来看这个问题。如果 public 接口里都是函数, 用户每次访问类的成员时就用不着抓脑袋去想:是该用括号还是不该用括号呢? 而且更重要的，采用函数可以更精确地控制数据成员的访问权这一事实吧?如果使数据成员为 public,每个人都可以对它读写; 如果用函数来获取或设定它的值,就可以实现禁止访问、只读访问和读写访问等多种控制。最后，一个很重要的优点是**功能分离 ( functional abstraction)**。如果用函数来实现对数据成员的访问,以后就有可能用一段计算来取代这个数据成员,而使用这个类的用户却一无所知。

- 条款 21: 尽可能使用 const
解释：使用 const 的好处在于它允许指定一种语意上的约束————某种对象不能被修改————编译器具体来实施这种约束。

- 条款 22: 尽量用“传引用”而不用“传值”
解释：除了拷贝和析构的代价。通过引用来传递参数还有另外一个优点:它避免了所谓的“切割问题(slicing problem)”。当一个派生类的对象作为基类对象被传递时,它(派生类对象)的作为派生类所具有的行为特性会被“切割”掉,从而变成了一个简单的基类对象。



- 条款 23: 必须返回一个对象时不要试图返回一个引用
解释：必须说你有一个“有理数”类，然后需要实现乘法。根据条款19，出于乘法对称性以及和基本类型兼容的考虑，将`operator*`实现为友元方法，为了防止对乘法的结果赋值，令返回值为const类型。本条款的内容是指，该函数的返回值一定是一个新的对象，无法绕过对新对象的构造过程，因此不能以引用的形式返回来节省构造的代价

- 条款 24: 在函数重载和设定参数缺省值间慎重选择
解释：答案取决于另外两个问题。第一,确实有那么一个值可以作为缺省吗? 第二,要用到多少种算法?一般来说,如果可以选择一个合适的缺省值并且只是用到一种算法,就使用缺省参数(参见条款 38)。否则,就使用函数重载。第一种情况举个例子，对多个值求最大值的函数可以使用缺省参数，而求平均值就必须使用重载了。另一种必须使用重载函数的情况是:想完成一项特殊的任务,但算法取决于给定的输入值。这种情况对于构造函数很常见:“缺省”构造函数是凭空(没有输入)构造一个对象,而拷贝构造函数是根据一个已存在的对象构造一个对象。有个时候构造函数必须执行错误检查,而拷贝构造函数不需要,所以需要两个不同的函数来实现,这就是重载。当然了，多个构造函数之间可以使用“代理构造”（见C++Primer）。

- 条款 25: 避免对指针和数字类型重载
解释：如果有一个这样的重载函数 f，在实际调用`f(0)`的时候,编译器根本不会多态，而是简单的调用int版本的函数，除非使用静态类型转换，但是这样写起来又不简洁。这个问题可以消除,但需要使用 C++语言最新增加的一个特性:成员函数模板(往往简称为成员模板)。但是，重要的一点是,以上所有那些产生正确工作的 NULL 的设计方案,只有在你自己是调用者的时候才有意义。如果你是设计被调用函数的人,写这样一个给别人使用的 NULL 其实没有多大的用处,因为你不能强迫你的调用者去使用它。

- 条款 26: 当心潜在的二义性
解释：当然,在没碰上二义的情况下,程序可以使用。这正是潜在的二义所具有的潜伏的危害性。它可以长时期地潜伏在程序里,不被发觉也不活动;一旦某一天某位不知情的程序员真的做了什么具有二义性的操作,混乱就会爆发。一种类似的二义的形式源于 C++语言的类型转换；另一种情况是，多继承(见条款 43)充满了潜在二义性的可能。最常发生的一种情况是当一个派生类从多个基类继承了相同的成员名时。当类 Derived 继承两个具有相同名字的函数时,C++没有认为它有错,此时二义只是潜在的。然而,对二义函数的调用迫使编译器面对这个现实,除非显式地通过指明函数所需要的基类来消除二义, 否则函数调用就会出错。

- 条款 27: 如果不想使用隐式生成的函数就要显式地禁止它
解释：然而,赋值运算符属于那种与众不同的成员函数,当你没有去写这个函数时,C++会帮你写一个(见条款 45)。而是当你不想使用它时怎么办呢？方法是声明这个函数(operator=),并使之为 private。显式地声明一个成员函数,就防止了编译器去自动生成它的版本;使函数为 private,就防止了别人去调用它。但是,这个方法还不是很安全,成员函数和友元函数还是可以调用私有函数,除非——如果你够聪明的话——不去定义(实现)这个函数。这样,当无意间调用了这个函数时,程序在链接时就会报错。
在C++Primer中提到了新标准的方法就是`myClass()=delete;`表示删除默认构造函数。

- 条款 28: 划分全局名字空间
用户于是可以通过三种方法来访问这一名字空间里的符号:将名字空间中的所有符号全部引入到某一用户空间;将部分符号引入到某一用户空间;或通过修饰符显式地一次性使用某个符号:


## 类和函数: 实现

- 条款 29: 避免返回内部数据的句柄
如果函数错误的返回了一个"句柄"(在本例中,是个指针),而这个句柄所指向的信息本来是应该隐藏在被调用函数所在的对象的内部。这样,这个句柄就给了调用者自由访问该句柄所指的私有数据的机会。


- 条款 30: 避免这样的成员函数:其返回值是指向成员的非 const 指针或引用, 但成员的访问级比这个函数要低


- 条款 31: 千万不要返回局部对象的引用,也不要返回函数内部用 new 初始化的指针的引用
除了需要在外部delete这个问题，因为常常有这种情况,operator*的结果只是临时用于中间值,它的存在只是为了计算一个更大的表达式。,假如你认为自己想出了什么办法可以避免"返回局部对象的引用"所
带来的不确定行为,以及"返回堆(heap)上分配的对象的引用"所带来的内存泄漏,那么,请转到条款 23,看看为什么返回局部静态(static)对象的引用也会工作不正常。看了之后,也许会帮助你避免头痛医脚所带来的麻烦。

- 条款 32: 尽可能地推迟变量的定义
如果定义了一个有构造函数和析构函数的类型的变量,当程序运行到变量定义之处时,必然面临构造的开销;当变量离开它的生命空间时, 又要承担析构的开销。这意味着定义无用的变量必然伴随着不必要的开销,所以只要可能,就要避免这种情况发生。你不仅要将变量的定义推迟到必须使用它的时候,还要尽量推迟到可以为它提供一个初始化参数为止。这样做,不仅可以避免对不必要的对象进行构造和析构,还可以避免无意义的对缺省构造函数的调用。而且,在对变量进行初始化的场合下,变量本身的用途不言自明,所以在这里定义变量有益于表明变量的含义。

- 条款 33: 明智地使用内联
程序世界和现实生活一样,从来就没有免费的午餐,内联函数也不例外。内联函数的基本思想在于将每个函数调用以它的代码体来替换。用不着统计专家出面就可以看出,这种做法很可能会增加整个目标代码的体积。在一台内存有限的计算机里,过分地使用内联所产生的程序会因为有太大的体积而导致可用空间不够。即使可以使用虚拟内存,内联造成的代码膨胀也可能会导致不合理的页面调度行为(系统颠簸),这将使你的程序运行慢得象在爬。过多的内联还会降低指令高速缓存的命中率,从而使取指令的速度降低,因为从主存取指令当然比从缓存要慢。另一方面,如果内联函数体非常短,编译器为这个函数体生成的代码就会真的比为函数调用生成的代码要小许多。如果是这种情况,内联这个函数将会确实带来更小的目标代码和更高的缓存命中率!
要牢记在心的一条是,inline 指令就象 register,它只是对编译器的一种提示,而不是命令。也就是说,只要编译器愿意,它就可以随意地忽略掉你的指令,事实上编译器常常会这么做。例如,大多数编译器拒绝内联"复杂"的函数(例如,包含循环和递归的函数);还有,即使是最简单的虚函数调用,编译器的内联处理程序对它也爱莫能助。(这一点也不奇怪。virtual 的意思是"等到运行时再决定调用哪个函数",inline 的意思是"在编译期间将调用之处用被调函数来代替",如果编译器甚至还不知道哪个函数将被调用,当然就不能责怪它拒绝生成内联调用了)。以上可以归结为:一个给定的内联函数是否真的被内联取决于所用的编译器的具体实现。幸运的是,大多数编译器都可以设置诊断级,当声明为内联的函数实际上没有被内联时,编译器就会为你发出警告信息。
为了提高程序开发质量,以上诸项一定要牢记在心。但在具体编程时,从纯实际的角度来看,有一个事实比其余的因素都重要:大多数调试器遇上内联函数都会无能为力。
慎重地使用内联,不但给了调试器更多发挥作用的机会,还将内联的作用定位到了正确的位置:它是一个根据需要而使用的优化工具。不要忘了从无数经验得到的这条 80-20 定律(参见条款 M16):一个程序往往花 80%的时间来执行程序中 20%的代码。这是一条很重要的定律,因为它提醒你,作为程序员的一个很重要的目标,就是找出这 20%能够真正提高整个程序性能的代码。你可以选择内联你的函数,或者没必要就不内联,但这些选择只有作用在"正确"的函数上才有意义。

- 条款 34: 将文件间的编译依赖性降至最低
解释：当看到一个对象 Person 的定义时,编译器虽然知道必须为它分配一个 Person 大小的内存,但怎么知道一个 Person 对象有多大呢? 唯一的途径是借助类的定义,但如果类的定义可以合法地省略实现细节,编译器怎么知道该分配多大的内存呢? 原则上说,这个问题不难解决。有些语言如 Smalltalk,Eiffel 和 Java 每天都在处理这个问题。它们的做法是,当定义一个对象时,只分配足够容纳这个对象的一个指针的空间。C++程序员完全可以自己来做到 "将一个对象的实现隐藏在指针身后"。除了编译分离的好处，因为看不到 Person 的实现细节,用户不可能写出依赖这些细节的代码。这是真正的接口和实现的分离。
分离的关键在于,"对类定义的依赖" 被 "对类声明的依赖" 取代了。所以, 为了降低编译依赖性,我们只要知道这么一条就足够了:只要有可能,尽量让头文件不要依赖于别的文件;如果不可能,就借助于类的声明,不要依靠类的定义。其它一切方法都源于这一简单的设计思想。

下面就是这一思想直接深化后的含义:
1. 如果可以使用对象的引用和指针,就要避免使用对象本身。定义某个类型的引用和指针只会涉及到这个类型的声明。定义此类型的对象则需要类型定义的参与。
2. 尽可能使用类的声明,而不使用类的定义。因为在声明一个函数时,如果用到某个类,是绝对不需要这个类的定义的,即使函数是通过传值来传递和返回这个类。（这意味着将提供类定义(通过#include 指令)的任务从你的函数声明头文件转交给包含函数调用的用户文件，就可以消除用户对类型定义的依赖,而这种依赖本来是不必要的、是人为造成的。）不要在头文件中再(通过#include 指令)包含其它头文件,除非缺少了它
们就不能编译。相反,要一个一个地声明所需要的类,让使用这个头文件的用户自己(通过#include 指令)去包含其它的头文件,以使用户代码最终得以通过编译。

Person 类仅仅用一个指针来指向某个不确定的实现,这样的类常常被称为**句柄类(Handle class)**或**信封类(Envelope class)**。你一定会好奇句炳类实际上都做了些什么。答案很简单:它只是把所有的函数调用都转移到了对应的主体类中,主体类真正完成工作。除了句柄类,另一选择是使 Person 成为一种特殊类型的抽象基类,称为**协议类(Protocol class)**。根据定义,协议类没有实现;它存在的目的是为派生类确定一个接口(参见条款 36)。所以,它一般没有数据成员,没有构造函数;有一个虚析构函数(见条款 14),还有一套纯虚函数,用于制定接口。 实例化一个包含纯虚函数的类是不可能的，但是，协议类的用户必然要有什么办法来创建新对象。这常常通过调用一个函数来实现,此函数扮演构造函数的角色,而这个构造函数所在的类即那个真正被实例化的隐藏在后的派生类。这种函数常常被称作工厂函数，这类函数和它创建的对象所对应的协议类(对象支持这个协议类的接口)是紧密联系的,所以将它声明为协议类的静态成员是很好的习惯。用户在编程时必须使用抽象类的指针或引用,因为抽象类不能被实例化。


记住那句话：没有免费的午餐。那么为了获得这种依赖性的降低，我们付出的代价是什么？答案是计算机科学领域最常见的一句话:它在运行时会多耗点时间,也会多耗点内存。句柄类的情况下,成员函数必须通过(指向实现的)指针来获得对象数据。这样,每次访问的间接性就多一层。此外,计算每个对象所占用的内存大小时,还应该算上这个指针。还有,指针本身还要被初始化(在句柄类的构造函数内),以使之指向被动态分配的实现对象,所以,还要承担动态内存分配(以及后续的内存释放)所带来的开销。对于协议类,每个函数都是虚函数,所有每次调用函数时必须承担间接跳转的开销(参见条款 14 和 M24)。而且,每个从协议类派生而来的对象必然包含一个虚指针(参见条款 14 和 M24)。这个指针可能会增加对象存储所需要的内存数量(具体取决于:对于对象的虚函数来说,此协议类是不是它们的唯一来源)。（参考[C++类大小详尽讲解](https://blog.csdn.net/longjialin93528/article/details/80160467)）。最后一点,句柄类和协议类都不大会使用内联函数。使用任何内联函数时都要访问实现细节,而设计句柄类和协议类的初衷正是为了避免这种情况。


## 继承和面向对象设计

- 条款 35: 使公有继承体现 "是一个" 的含义
**C++面向对象编程中一条重要的规则是:公有继承意味着 "是一个" 。一定要牢牢记住这条规则。**当写下类 D("Derived" )从类 B("Base")公有继承时,你实际上是在告诉编译器(以及读这段代码的人):类型 D 的每一个对象也是类型 B 的一个对象,但反之不成立;你是在说:B 表示一个比 D 更广泛的概念,D 表示一个比 B 更特定概念;你是在声明:任何可以使用类型 B 的对象的地方,类型 D 的对象也可以使用,因为每个类型 D 的对象是一个类型 B 的对象。相反,如果需要一个类型 D 的对象,类型 B 的对象就不行:每个 D **是一个** B, 但反之不成立。
只是公有继承才会这样。也就是说,只是 Student 公有继承于 Person 时, C++的行为才会象我所描述的那样。私有继承则是完全另外一回事(见条款42),至于保护继承,好象没有人知道它是什么含义。另外,Student "是一个"Person 的事实并不说明 Student 的数组 "是一个" Person 数组。
对于 "所有鸟都会飞,企鹅是鸟,企鹅不会飞" 这一问题。可以使用更复杂的继承关系解决，（比如可以增加一层抽象类来区分会飞的鸟和不会飞的鸟；或者将flyable实现为混入类）。还可以考虑用另外一种方法来处理。也就是对 penguin 重新定义 fly 函数,使之产生一个运行时错误。解释型语言如 Smalltalk 喜欢采用这种方法,但这里要认识到的重要一点是,上面的代码所说的可能和你所想的是完全不同的两回事。它不是说,"企鹅不会飞",而是说,"企鹅会飞,但让它们飞是一种错误"。怎么区分二者的不同?这可以从检测到错误发生的时间来区分。"企鹅不会飞" 的指令是由编译器发出的,"让企鹅飞是一种错误" 只能在运行时检测到。

- 条款 36: 区分接口继承和实现继承
(公有)继承的概念看起来很简单,进一步分析,会发现它由两个可分的部分组成:函数接口的继承和函数实现的继承。这两种继承类型的区别和本书简介中所讨论的函数声明和函数定义间的区别是完全一致的。作为类的设计者,有时希望派生类只继承成员函数的接口(声明);有时希望派生类同时继承函数的接口和实现,但允许派生类改写实现;有时则希望同时继承接口和实现,并且不允许派生类改写任何东西。**定义纯虚函数的目的在于,使派生类仅仅只是继承函数的接口。**声明一个除纯虚函数外什么也不包含的类很有用。这样的类叫**协议类(Protocol class)**,它为派生类仅提供函数接口,完全没有实现。协议类在条款 34 中介绍过,并将在条款 43 再次提及。声明简单虚函数的目的在于,使派生类继承函数的接口和缺省实现。实际上,为简单虚函数同时提供函数声明和缺省实现是很危险的。那么怎么让接口和缺省实现应该分离？可以借助于这一事实:纯虚函数必须在子类中重新声明,但它还是可以在基类中有自己的实现。只不过在派生类的具体接口实现中中要明确通过基类调用积累的缺省纯虚函数继承。（为纯虚函数提供定义。这种定义不会存入虚表，因此基类本身仍然是抽象类，并且派生类仍然需要提供一个显式实现。但更简便的方法是在派生类中调用基类的实现，注意此处不能使用虚函数，而是直接使用函数名调用。）**声明非虚函数的目的在于,使派生类继承函数的接口和强制性实现。**

补充：那么可不可以只继承实现？通过基类的protected中的函数得到的函数是之继承了实现。（参考：[C++继承和组合——带你读懂接口和mixin，实现多功能自由组合](https://blog.csdn.net/yunqiinsight/article/details/80017968)。）所以总的来说，C++的继承方式中：public继承包括基类的接口与实现；protected继承只包括基类的实现，且可继续传递；private继承只包括基类的实现，且不可继承传递。因为只有public继承是isa的关系，所以只有public继承的派生类可以隐式转换为基类的引用或者指针。


- 条款 37: 决不要重新定义继承而来的非虚函数
非虚函数是静态绑定的(参见条款 38)。这意味着,因为 pB 被声明为指向 B 的指针类型,通过 pB 调用非虚函数时将总是调用那些定义在类 B 中的函数 ---- 即使 pB 指向的是从 B 派生的类的对象。相反,虚函数是动态绑定的(再次参见条款 38),因而不会产生这类问题。如果 mf 是虚函数,通过 pB 或 pD 调用 mf 时都将导致调用 D::mf,因为 pB 和 pD 实际上指向的都是类型 D 的对象。所以,结论是,如果写类 D 时重新定义了从类 B 继承而来的非虚函数 mf, D 的对象就可能表现出精神分裂症般的异常行为。
从原理上看，公有继承反应“是一个”的关系，而非虚函数表现的是“共性行为”，如果需要在派生类中重写非虚函数，那么意味着要么该公有继承不是“是一个”的关系，要么非虚函数没有表现“共性行为”，需要改为虚函数。


- 条款38：条款 38: 决不要重新定义继承而来的缺省参数值
虚函数是动态绑定的,意思是说,虚函数通过哪个对象被调用,具体被调用的函数就由那个对象的动态类型决定。这个很容易理解，但是,将虚函数和缺省参数值结合起来分析就会产生问题,因为,虚函数是动态绑定的,但缺省参数是静态绑定的。这意味着你最终可能调用的是一个定义在派生类,但使用了基类中的缺省参数值的虚函数。为什么 C++坚持这种有违常规的做法呢?答案和运行效率有关。如果缺省参数值被动态绑定,编译器就必须想办法为虚函数在运行时确定合适的缺省值,这将比现在采用的在编译阶段确定缺省值的机制更慢更复杂。


- 条款 39: 避免 "向下转换" 继承层次
任何时候发现自己写出 "如果对象属于类型 T1,做某事;但如果属于类型T2,做另外某事" 之类的代码,就要扇自己一个耳光。这不是 C++的做法。是的,在 C,Pascal,甚至 Smalltalk 中,它是很合理的做法,但在 C++中不是。在 C++中,要使用虚函数。记得吗?对于一个虚函数,编译器可以根据所使用对象的类型来保证正确的函数调用。所以不要在代码中随处乱扔条件语句或开关语句;让编译器来为你效劳。
"向下转换" 可以通过几种方法来消除。最好的方法是将这种转换用虚函数调用来代替,同时,它可能对有些类不适用,所以要使这些类的每个虚函数成为一个空操作。第二个方法是加强类型约束,使得指针的声明类型和你所知道的真的指针类型之间没有出入。为了消除向下转换,无论费多大工夫都是值得的,因为向下转换难看、容易导致错误,而且使得代码难于理解、升级和维护。
有的时候，你在用一个只读的代码库，你发现你不得不用`static_cast`来进行向下转换。但是实际上，还是有比这种转换更好的办法。这种方法称为 "安全的向下转换",它通过 C++的 dynamic_cast 运算符(参见条款 M2)来实现。当对一个指针使用 dynamic_cast 时,先尝试转换,如果成功(即,指针的动态类型(见条款 38)和正被转换的类型一致),就返回新类型的合法指针;如果dynamic_cast 失败,返回空指针。

- 条款 40: 通过分层来体现 "有一个" 或 "用...来实现"
使某个类的对象成为另一个类的数据成员,从而实现将一个类构筑在另一个类之上,这一过程称为 "分层"(Layering)。顺便说一句,当通过分层使两个类产生联系时,实际上在两个类之间建立了编译时的依赖关系。关于为什么要考虑到这一点以及如何减少这方面的麻烦,参见条款 34。

- 条款 41: 区分继承和模板
考虑这么两种场景，一种是希望实现一个堆栈类，堆栈类要支持不同的数据类型，但是共有的操作是构造、析构、压栈、出栈和获取长度；第二种希望创建一个类表示猫，而且是各种各样的猫，但是同样要关注猫的两个公共行为：吃和睡，但是"每一种猫吃和睡都有各自惹人喜爱的方式"。这两个问题的说明听起来很相似,但却导致完全不同的两种设计。为什么?答案涉及到"类的行为" 和 "类所操作的对象的类型"之间的关系。对于堆栈和猫来说,要处理的都是各种不同的类型(堆栈包含类型为 T 的对象,猫则为品种 T),但你必须问自己这样一个问题:类型 T 影响类的行为吗?如果 T 不影响行为,你可以使用模板。如果 T 影响行为,你就需要虚函数,从而要使用继承。
要注意一点，模板是 C++最有用的组成部分之一,但一旦开始经常性地使用它,你会发现,如果实例化一个模板一百次,你就可能实例化了那个模板的代码一百次。例如 Stack 模板,构成 Stack<int>成员函数的代码和构成 Stack<double>成员函数的代码是完全分开的。有时这是不可避免的,但即使模板函数实际上可以共享代码,这种代码重复还是可能存在。这种目标代码体积的增加有一个名字:模板导致的 "代码膨胀"。这不是件好事。解决这个问题的办法在条款 42 中。


- 条款 42: 明智地使用私有继承
在弄清含义之前,让我们先看看行为。私有继承有那些行为特征呢?" 那好吧。关于私有继承的第一个规则正如你现在所看到的:和公有继承相反,如果两个类之间的继承关系为私有,编译器一般不会将派生类对象(如 Student)转换成基类对象(如 Person)。这就是上面的代码中为对象 s 调用 dance 会失败的原因。第二个规则是,从私有基类继承而来的成员都成为了派生类的私有成员,即使它们在基类中是保护或公有成员。行为特征就这些。
这为我们引出了私有继承的含义:私有继承意味着 "用...来实现"。如果使类 D 私有继承于类 B,这样做是因为你想利用类 B 中已经存在的某些代码,而不是因为类型 B 的对象和类型 D 的对象之间有什么概念上的关系。因而,私有继承纯粹是一种实现技术。用条款 36 引入的术语来说,私有继承意味着只是继承实现,接口会被忽略。如果 D 私有继承于 B,就是说 D 对象在实现中用到了 B 对象,仅此而已。私有继承在软件 "设计" 过程中毫无意义,只是在软件 "实现" 时才有用。
私有继承意味着 "用...来实现" 这一事实会给程序员带来一点混淆,因为条款 40 指出,"分层" 也具有相同的含义。怎么在二者之间进行选择呢?答案很简单:尽可能地使用分层,必须时才使用私有继承。
当需要解决模板导致的代码膨胀问题时可以考虑如下思路：在基类中使用`void*`定义数据类型，在使用的时候需要静态类型转换为具体的类型，这部分静态类型转换的工作通过私有继承一个接口类来实现。如果想要多个不同的类型的接口类，此时在考虑使用类型模板。
分层一般来说是更好的方法,但在有虚函数要被重新定义的情况下,需要使用私有继承。

- 条款 43: 明智地使用多继承
前置知识：[C++虚基类详解](https://www.cnblogs.com/yiranlaobaitu/p/3764422.html)

C++中,关于 MI 一条不容争辩的事实是,MI 的出现就象打开了潘朵拉的盒子,带来了单继承中绝对不会存在的复杂性。其中,最基本的一条是二义性(参见条款 26)。即使其中一个被继承的同名函数是私有成员从而不能被访问,二义还是存在。解决问题的方法是显式地限制修饰成员，但是这样做不仅很笨拙,而且还带来限制。当显式地用一个类名来限制修饰一个虚函数时,函数的行为将不再具有虚拟的特征。
除了二义性的问题，还有更严重的问题。就是假设 C 多继承了 A 和 B ，A 和 B 有一个同名的虚函数 f ，那么 C 可以调用以及重写 f ，如果 C 想分别重写两个基类中的 f 怎么办？令人沮丧的是,这不可能,因为一个类只允许有唯一一个没有参数、名称为 draw 的函数。(这个规则有个例外,即一个函数为 const 而另一个不是的时候 ---- 见条款 21)从某一方面来说,这个问题很严重,严重到足以成为修改 C++语言的理由。但后来又发现,可以通过增加一对新类来巧妙地避开这个问题。这是一个集纯虚函数,简单虚函数和内联函数(参见条款 33)综合应用之大成的方法,值得牢记在心。首先,它解决了问题,这个问题说不定哪天你就会碰到。其次,它可以提醒你,使用多继承会导致复杂性。是的,这个方法解决了问题,但仅仅为了重新定义一个虚函数而不得不去引入新的类,你真的愿意这样做吗?AuxLottery 和 AuxGraphicalObject 类对于保证类层次结构的正确运转是必需的,但它们既不对应于问题范畴(problem domain )的某个抽象,也不对应于实现范畴(implementation domain)的某个抽象。它们单纯是作为一种实现设备而存在,再没有别的用处。你一定知道,好的软件是 "设备无关" 的,这条法则在此也适用。
另外一个多继承导致的经典问题就是“钻石继承”。A--(B C)--D这种继承结构。注意，往往会在空间和时间上强加给用户额外的开销。因为虚基类常常是通过对象指针来实现的,并非对象本身。如果 A 作为 "非虚" 基类,类型 D 的对象在内存中的分布通常占用连续的内存单元;如果 A 作为 "虚" 基类,有时,类型 D 的对象在内存中的分布占用连续的内存单元,但其中两个单元包含的是指针,指向包含虚基类数据成员的内存单元。（参考[C++类大小详尽讲解](https://blog.csdn.net/longjialin93528/article/details/80160467)）。这导致是否将一个类定义成虚基类虚基类需要有对程序整体继承结构的准确认识，（这和虚函数不一样。是否将函数定义成虚函数只需要考虑局部结构，即该函数是希望继承接口、还是接口与不可修改的实现、还是接口与默认实现）。
除了二义性和整体认知的困难，再有就是构造函数的问题。普通基类的构造由它的直接派生类负责，而虚基类的构造由其最底层的派生类负责，这就使得每次延长派生链的时候，需要改变链中对虚基类的构造函数的负责人。(避免这个问题的一个好办法是:消除对虚基类传递构造函数参数的需要。最简单的做法是避免在这样的类中放入数据成员。这本质上是 Java 的解决之道:Java 中的虚基类(即,"接口")禁止包含数据)。好在这个问题好像可以被编译器检查到。
另外一个是虚函数优先度的问题，假设A、C各自有自己的一个同名重写的虚函数，在 D 中调用会怎样呢？如果 A 是非虚基类，那么会出现二义性，可是如果A是虚基类，那么就没有二义性了，优先调用C中的虚函数。
上面的讨论中你会注意到,这些复杂性很多是由于使用虚基类引起的。如果能避免使用虚基类 ----即,如果能避免产生那种致命的钻石形状继承图 ---- 事情就好处理多了。


- 条款 44: 说你想说的;理解你所说的
这一部分是这一章的一个总结："说出你想说的" 只是成功的一半。事情的另一面是 "理解你所说的",这一点同样重要。例如,将成员函数声明为非虚函数会给子类带来限制,如果没有认识到这一点就随便这样做将是不负责任的行为 ---- 除非你完全是有意这么做。声明一个非虚成员函数,你实际上是在说这个函数表示了一种特殊性上的不变性;如果不明白这一点,将会给程序带来灾难。公有继承和 "是一个" 的等价性,以及非虚成员函数和 "特殊性上的不变性" 的等价性,是 C++构件如何和设计思想相对应的例子。

下面的列表总结了这些对应关系中最重要的几个。
1. 共同的基类意味着共同的特性。如果类 D1 和类 D2 都把类 B 声明为基类, D1 和 D2 将从 B 继承共同的数据成员和/或共同的成员函数。见条款 43。
2. 公有继承意味着 "是一个"。如果类 D 公有继承于类 B,类型 D 的每一个对象也是一个类型 B 的对象,但反过来不成立。见条款 35。
3. 私有继承意味着 "用...来实现"。如果类 D 私有继承于类 B,类型 D 的对象只不过是用类型 B 的对象来实现而已;类型 B 和类型 D 的对象之间不存在概念上的关系。见条款 42。
4. 分层意味着 "有一个" 或 "用...来实现"。如果类 A 包含一个类型 B 的数据成员,类型 A 的对象要么具有一个类型为 B 的部件,要么在实现中使用了类型 B 的对象。见条款 40。

对于公有继承来说：
1. 纯虚函数意味着仅仅继承函数的接口。如果类 C 声明了一个纯虚函数 mf,C 的子类必须继承 mf 的接口,C 的具体子类必须为之提供它们自己的实现。见条款 36。
2. 简单虚函数意味着继承函数的接口加上一个缺省实现。如果类 C 声明了一个简单(非纯)虚函数 mf,C 的子类必须继承 mf 的接口;如果需要的话,还可以继承一个缺省实现。见条款 36。实际上,为简单虚函数同时提供函数声明和缺省实现是很危险的（万一忘了实现也不会报错）。
3. 非虚函数意味着继承函数的接口加上一个强制实现。如果类 C 声明了一个非虚函数 mf,C 的子类必须同时继承 mf 的接口和实现。实际上,mf 定义了 C 的 "特殊性上的不变性"。见条款 36。这种方式可以被应用为一种机制,为简单的(非纯)虚函数提供 "比一般做法更安全" 的缺省实现（因为缺省行为需要被明确调用）。

## 杂项

- 条款 45: 弄清 C++在幕后为你所写、所调用的函数
一个空类什么时候不是空类? ---- 当 C++编译器通过它的时候。如果你没有声明下列函数,体贴的编译器会声明它自己的版本。这些函数是:一个拷贝构造函数,一个赋值运算符,一个析构函数,一对取址运算符。另外,如果你没有声明任何构造函数,它也将为你声明一个缺省构造函数。所有这些函数都是公有的。
默认情况下,固定类型的对象拷贝构造(赋值)时是从源对象到目标对象的 "逐位" 拷贝。对于从别的类继承而来的类来说,这条规则适用于继承层次结构中的每一层,所以,用户自定义的构造函数和赋值运算符无论在哪一层被声明,都会被调用。（假设在派生类中没有手动调用基类的构造函数，那么编译器会自动调用基类的默认构造函数。）

- 条款 46: 宁可编译和链接时出错,也不要运行时出错
运行时错误的概念和 C++没什么关系,就象在 C 中一样。没有下溢,上溢,除零检查;没有数组越界检查,等等。一旦程序通过了编译和链接,你就得靠自己了 ---- 一切后果自负。这一思想背后的动机当然在于效率:没有运行时检查,程序会更小更快。（解释型的语言可以提供强大的运行时系统来处理执行期间的错误。）不要忘了你是在用 C++编程。即使发现 Smalltalk/LISP 的方法很吸引人,也要忘掉它们。要避免运行时错误。只要有可能,就要让出错检查从运行时退回到链接时,或者,最理想的是,编译时。对于运行时错误来说,情况大不一样。在某次运行期间程序没有产生任何运行时错误,你就能确信另一次不同的运行期内不会产生错误吗?
将检查从运行时转移到编译或链接时一直是值得努力的目标,只要实际可行,就要追求这一目标。这样做的奖赏是,程序会更小,更快,更可靠。

- 条款 47: 确保非局部静态对象在使用前被初始化
非局部静态对象指的是这样的对象: 定义在全局或名字空间范围内(例如:theFileSystem 和 tempDir),在一个类中被声明为 static,或,在一个文件范围被定义为 static。对于不同被编译单元中的非局部静态对象,你一定不希望自己的程序行为依赖于它们的初始化顺序,因为你无法控制这种顺序。让我再重复一遍:你绝对无法控制不同被编译单元中非局部静态对象的初始化顺序。（mywiser中存在大量的在类中定义的静态对象，目的是防止没有必要的多个对象的代价，比如indexer中的tokenizer就是一定静态对象因为tokenizer可以共用）。
但是,如果你不强求一定要访问 "非局部静态对象",而愿意访问具有和非局部静态对象 "相似行为" 的对象(不存在初始化问题),难题就消失了。取而代之的是一个很容易解决的问题,甚至称不上是一个问题。这种技术 ---- 有时称为**Singleton pattern**---- 本身很简单。首先,把每个非局部静态对象转移到函数中,声明它为 static。其次,让函数返回这个对象的引用。这样,用户将通过函数调用来指明对象。换句话说,用函数内部的 static 对象取代了非局部静态对象。虽然关于 "非局部" 静态对象什么时候被初始化,C++几乎没有做过说明;但对于函数中的静态对象(即,"局部" 静态对象)什么时候被初始化,C++却明确指出:它们在函数调用过程中初次碰到对象的定义时被初始化。这样做的另一个好处是,如果这个模拟非局部静态对象的函数从没有被调用,也就永远不会带来对象构造和销毁的开销;而对于非局部静态对象来说就没有这样的好事。使用单例模式后，用户还是完全和以前一样编程,只是现在他们所用的是返回对象引用的函数,而不是对象本身。

- 条款 48: 重视编译器警告
举了一个例子：`warning: D::f() hides virtual B::f()`

- 条款 49: 熟悉标准库
C++库并非提供了一切(很明显的是,没有提供并发和图形用户接口的支持),但确实提供了很多。几乎任何事你都可以求助于它。
首先，对于头文件的命名，举个例子，`<string.h>`是旧的 C 头文件,对应的是基于 char* 的字符串处理函数; `<string>`是包装了 std 的 C++头文件,对应的是新的 string 类(看下文);`<cstring>`是对应于旧 C 头文件的 std 版本。
关于标准库,需要知道的第二点是,库中的一切几乎都是模板。在标准库中你无法避开模板,但如果只是习惯于和 char 类型的流和字符串打交道,通常可以忽略它们。这是因为,对这些组件的 char 实例,标准库都为它们定义了 typedef,这样你就可以在编程时继续使用 cin,cout,cerr 等对象,以 及 istream , ostream , string等类型,不必担心cin的真实类型是basic_istream<char>以及string的真实类型是basic_string<char>。

- 条款 50: 提高对 C++的认识
为什么隐式生成的拷贝构造函数和赋值运算符要象现在这样工作呢,尤其是指针(参见条款 11 和 45)?因为这是 C 对 struct 进行拷贝和赋值的方式,和 C 兼容很重要。
为什么析构函数不自动被声明为 virtual(参见条款 14),为什么实现细节必须出现在类的定义中(参见条款 34)呢?因为不这样做就会带来性能上的损失,效率很重要。
为什么 C++不能检测非局部静态对象之间的初始化依赖关系(参见条款 47)呢?因为 C++支持单独编译(即,分开编译源模块,然后将多个目标文件链接起来,形成可执行程序),依赖现有的链接器,不和程序数据库打交道。所以,C++编译器几乎不可能知道整个程序的一切情况。
为什么 C++不让程序员从一些繁杂事务如内存管理(参见条款 5-10)和低级指针操作中解脱出来呢?因为一些程序员需要这些处理能力,一个真正的程序员的需要至关重要。

