---
layout: post
date: 2018-11-19 15:23:51
title: 《C++Primer》第十六章：模板与泛型编程
category: 读书笔记
tags:
- reading
- C++
keywords:
description:
---


## 函数模板
1. 面向对象编程和泛型编程都能处理在编写程序的时候不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中在编译时就能获知类型了。（因为在编写模板的时候不确定类型，但是在使用模板的时候要给出具体类型。模板是一种“蓝图”，在编译的时候这种蓝图已经可以转化成具体的类或者函数了。）
2. 当调用函数模板的时候，编译期通常可以通过函数实参来推断模板实参。当编译器实例化一个模板的时候，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。
3. 类型模板参数可以使用`typename`或者`class`，前者更直观但是旧的编译器可能不支持。非类型模板参数使用特定的类型名指定，非类型模板参数必须是一个值，而且是常量表达式。
4. 函数模板可以声明为`inline`或者`constexpr`的，就像非模板函数一样。
5. 编写泛型代码的两个重要原则：一、模板中的函数参数是const的引用。二、函数体中的条件判断仅使用`<`比较运算。前者除了更快，还保证了函数可以用于不能拷贝的类型。后者降低了函数模板对位置类型的要求。

<!-- more -->

6. 编译器遇到模板定义并不生成代码，只有当实例化出模板的一个特定版本的时候编译器才会生成代码。

## 类模板
1. 与函数模板不同的地方在于，编译器不能为类模板自动推断模板类型。
2. 默认情况下，一个类模板的成员函数只有当程序用到它的时候才会实例化。
3. 当我们在类模板外定义其成员的时候，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。

## 成员模板
1. 成员模板不能是虚函数

