1. 到目前为止，所有的对象都有严格定义的生命周期。全局对象在程序启动时分配，在程序销毁时结束。局部自动对象，进入其所在的程序块时，离开时销毁。局部static对象在第一次使用前分配，程序结束时销毁。而动态对象就需要被显式释放的时候才会被销毁。
2. 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。这两种内存中的对象由编译器自动创建和销毁。除了这两种内存，每个程序还拥有一个内存池，这部分内存就是堆，用于存储动态分配的对象，即程序运行时分配的对象。
3. `shared_ptr`：当拷贝一个`shared_ptr`时计数器都会递增，比如拷贝构造、作为函数参数、作为函数返回值时，其引用计数会增加。当给`shared_ptr`赋予新值或是被销毁（例如离开作用域），计数器会递减。
4. 单独使用一个智能指针我们可能不会忘记释放内存，容器出错的是复杂的情况。比如当用一个vector保存智能指针的时候，然后用一个指针不会被用到，那么就要erase掉他们。
5. 使用动态内存的常见原因：（1）程序不知道需要使用多少对象。（2）程序不知道对象的准确类型。（3）**程序需要在多个对象之间共享数据。**
6. 可以用大括号括起来一个作用域，在作用域内使用智能指针，那么退出作用域时可以释放引用计数为零的对象。
7. 在`memory`中的allocator用于对对象更精细的内存管理，将内存的`allocate`与对象自身的`construct`相分离。
