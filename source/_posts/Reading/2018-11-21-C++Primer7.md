1. 成员函数通过一个`this`隐式参数来访问调用它的对象，this指针指向该对象的地址。当使用成员变量的时候，this被隐式使用。
2. 成员函数紧随参数列表后面的const关键字。默认情况是，this是一个指向类类型的常量指针，在const成员函数中，this指针是一个指向常量类类型的常量指针。
3. 编译器分两步处理类，首先编译成员的声明，然后才轮到成员函数体。因此成员函数体可以随意使用类中的其他成员函数而无需在意这些成员出现的次序。
4. 类外部定义的成员的名字必须包含他所属的类名。
5. 默认构造函数无需任何实参。
6. c++11新标准中，如果我们需要默认的行为，可以在参数列表后加上`= default`来要求编译器生成构造函数。default出现在类内部是，则默认构造函数是内联的。
7. 自定义构造函数要给出**构造函数初始值列表**，通过冒号给出。
8. 自定义对象还需要实现，拷贝、赋值和析构。如果我们以传值形式返回对象，该对象会调用拷贝构造函数。编译器也会默认生成这些函数，默认版本就是对对象的每个成员进行拷贝、赋值和销毁。如果用vector作为成员，通过默认的版本可以胜任。
9. class和struct基本没有区别，唯一的区别是默认的访问权限不同。前者默认private，后者默认public。
10. 类可以让其他类或者函数访问其非共有成员，方法是使用友元声明。友元不是类的成员，也不受所在的区域访问控制级别的约束。友元声明只是声明权限，而非通常意义上的函数声明。可以把其它函数、其他类、或者其他类的成员函数定义为友元。类内的友元定义会被声明为隐式内联。友元不具有传递性，也就是说每个类只管理自己的友元。
11. 使用`multable`声明可变数据成员，可变数据成员永远可以被修改，即使在一个const对象中。
12. 类内初始值必须以等号或者花括号给出。
13. 一个常量对象上只能调用常量成员函数。因此肯定成员函数是否是const，可以重载同一个函数。对于返回引用的成员函数来说，可以更好地支持链式调用。
14. 可以在类中重定义类型，类似于`string::size_type`这种效果。
15. 之前已经提到过，类内部会首先编译成员的所有声明，类全部可见之后才编译函数体，因此名字的查找范围无关顺序。
16. 对于构造函数，即使没有用冒号显式给出初始化列表，C++也会在构造函数函数体之前默认初始化参数，函数体内只不过是对成员变量进行赋值。因此对于const成员变量，一定需要手动初始化。
17. 成员变量的初始化顺序与构造函数中的初始化列表的顺序无关，只与他们出现在类内的顺序有关。
18. C++11中扩展了构造函数的功能，可以使用委托构造函数，委托构造函数使用它所述的类的其他构造函数执行自己的初始化过程。使用方法就是初始化列表替换为执行其他构造函数。
19. 如果构造函数只接受一个实参，那么这种构造函数被称为转换构造函数，提供了一种实参类型向类类型的隐式类型转换方法。但是编译器只会自动执行一步隐式类型转换。对于这种转换构造函数，添加`explicit`关键字可以阻止这种隐式类型转换。另外
20. “聚合类”要求：（1）所有成员都是public。（2）没有定义任何构造函数。（3）没有类内初始值。（4）没有基类也没有virtual函数。
21. “常量类”
22. 静态成员存在于任何对象之外，对象中没有静态成员的数据，静态成员函数没有this指针。直接通过类加上作用域运算符访问静态成员，也可以通过对象的点号或者箭头符号来访问。在外部定义静态成员函数时不能使用static关键字，该关键字只能出现在类内部的声明语句。
23. 静态成员的初始化应该在main函数外。类的静态数据成员存在于程序的整个生命周期之内。
24. 不一定要在友元函数之前声明好该函数，友元声明会隐式的假定该名字在当前作用域中可见。甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明使得函数可见，否则该类自己的成员函数无法调用该友元函数。
