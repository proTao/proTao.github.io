### 763. Patition Labels
还算不错，需要遍历一遍拿到最右位置，然后是N的空间复杂度，N的时间复杂度。

### 524. Longest Word in Dictionary through Deleting
和703有一点像，需要先遍历一遍，这里需要存下一个字符出现的每一个位置。然后加了大量的trick。

### 287. Find he Duplicate Number
这道题思路也是很清奇了。首先先不考虑节点0，因为题目规定所有的节点的值的范围都在1到n范围内，因此1-n范围内必定形成环（证明方法类似于1自己不形成环，那么就要指向非1的数，假如指向2，然后为了不形成环，2不能指向1和2，类似的递推，n个点不形成环只能指向第n+1个节点），然后节点0由于题目要求一定指向1到你的某个节点。

### 881. Boats to Save People
排序，两个指针，一个指向当前最大的，一个指向当前最小的。

### 75. Sort Colors
考虑快排其实就是一个双指针问题，这道题就迎刃而解了，甚至更简单一些。第一遍划分为左边是0右边是非0，然后对右侧进行第二遍划分，划分为左边是1右边是2即可。

### 11. Container With Most Water
思路挺简单的，但就是自己想不到，尽管知道这是一道双指针问题但是并没有什么乱用......思路是维护两个指针，一个在头一个在尾，因为面积被两只之间较短的长度所限制，那么每次就将较短的指针往里面移动一位，这样是可能遇到面积变大的情况的，如果移动的是较长的指针，那么面积一定不会变大。

### 42. Trapping Rain Water
这道题是面试中遇到的一道题，当时的做法是Solution中的方法2，也算是DP，但是既然是双指针问题就会有更好的方法。Solution中给了一个一次遍历就得到解的方法，类似于11，维护左右两个指针，每次移动高度较小的那个指针，并且计算被移动的指针所在的位置所提供的水的多少，只需要和所在一侧的高度比较就行，原因在于每次移动的是较矮的一方，因此另一侧的高度肯定更高。


