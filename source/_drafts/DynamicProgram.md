---
title: DynamicProgram
category: 程序员的玩具
tags: algorithm
---

### 经典
编辑距离(作业查重) Hischberg算法，背包问题，LCS问题，维特比算法，Bellman-Ford算法

### 746
用了闭包技巧，发现的确在一定程度上可以替代类的实现。但是用了O(n)的空间，这个我想到了可以用常数空间，但是没有写。

1. 子问题划分
到了第k阶要考虑别的就是用最小的代价上到顶层，那么上到第k阶花费的最小代价这个就是子问题，只要我能有一个方案，能够以最小的代价到达前k阶的任意一阶，那么我就可以到达第k+1阶。

2. 递推公式
f(k) = min(f(k-1)+cost(k-1), f(k-2)+cost(k-2))

3. 重复子问题

### 70

类似于746

### 53

[清晰解题： 寻找最大子数列-Kadane算法](https://blog.csdn.net/lengxiao1993/article/details/52303492)

这道题可以仔细琢磨琢磨。

首先想到的是划分子问题，如果数组长度为n。假设我们知道了长度为k的前缀数组的最大连续子数组，对求解k+1长度的前缀数组有没有帮助？答案是没有的。因为我们不知道第k+1个元素能不能和前面的最大子数组连上。假设k=4是[1,2,3,-1]，或者[-1,1,2,3]，子问题的解都是6，假设后面的元素是1，但是两种情况对应的k=5的子问题的解是不同的，前者是6后者是7。

那么我后续的思路就是返回一个标志位？标志最大子数组在前缀数组中包不包括最后一个元素，然后标志位为真时f(k+1)=max(f(k),f(k)+A[k+1])，当标志位为假时，f(k+1)=max(f(k),A[k+1])。但是这样又有问题，假设前缀数组是[1,2,-1]，最大子数组是3，然而整个的数组是[1,2,-1,1,1,1,1,1]，那么返回的3，后面连续的1会被忽视。

如果想要改进上面的问题，必须要解决的问题就是子问题的连贯性，不能断。注意到如果我有一个子数组a，如果他相邻的一个子数组b，b的元素和是正数，那么a和b连接得到的子数组的元素和肯定比a大。那么如果我让a是前k个元素中以k结尾的最大子数组，b是第k+1个元素，令子问题是a，我可以放心的更新子问题，并让k自增1：如果第a+b是正数，那么f(k+1)=f(k)+A[k+1]，如果第a+b是负数，那么意味着前缀数组根本无法用来让子数组变大，令f(k+1)=0。

[−2, 1, −3, 4, −1, 2, 1, −5, 4]，看这个数组，我始终要维护一个a数组计算子问题，a数组为[0,1,0,4,3,5,6,1,5]，计算这个数组是注意起始条件，a[0]等于0是因为-2与其要还不如不要，对于1来说肯定不希望扩展前面[-2]这个子数组，因此第一个元素是0，第二个元素是1。再注意到，a[3]是4，然后a[4]是3，尽管后面是-1，但是还是要加上-1，因为[4,-1]这个子数组是正数，对于后面的与他相邻的子数组来说，加上他肯定是有好处的，这给了后面希望。然后a数组中最大的就是问题的解。

而Kadane算法在此问题上更进一步，思路就是我在不停的生成a数组，我想知道a数组的最大值，我完全不需要把他存下来，这实际上就是处理流数据的思路。

可以看到讨论区排名第一的discussion的思路是：

> 显然，这是一个优化（求最优解）问题，那么通常情况下这种问题我们可以用DP去解。如果想到了DP，那么接下来就是要找到子问题的形式。首先想到的是子数组A[i..j]中的最大子数组。也是遇到子问题之间无法衔接的问题。

重点还是在子问题形式的提取上，121就是一个很好的很类似的练习题。


### 198
这道题做起来很简单，不过能不能看出这道题就是fibonacci数列？？规约问题的能力可太重要了。反正我是没有。

### 303
对于子数组求和，要一下子想到转化为accumulate函数，能够很大概率将问题转化为线性时间复杂度。这道题想到缓存没啥的，题目提示的已经太明显了，但是一开始我用的是O(n^2)复杂度的常规缓存思路，按照Solution应该是通过的咋没过呢。。。

### 338
这道题子问题比较好定义出来，就是countBits(k)，返回一个长度是k+1的数组，然后在递推countBits(k+1)的时候，思路可就比较多了。我思路的入手点在于，观察到2的正整数次幂的二进制位数都是1，假设求countSum(15)，可以一下子确定的是再返回结果res数组中，第1、2、4、8位都是1，然后第0位是0，然后第3位是第1位加1，第5~7位是1~3位加1，等等。然后我就这么实现了，最后不是特别快，因为IE我需要多维护两个变量表示我当前正在处理的区间。
但是上面的思路其实已经可以提炼出一个递推公式了，就是f(x)=f(x-<小于x的最大整数幂>)+1，然后我又实现了，这次还不错，但是还需要多维护一个变量，存储当前的最小整数幂。
然后看solution中有一个思路很6，是f(x)=f(x>>1)+f(x%2)，其实区别就在于上面的思路我拆开考虑最高位，下面的思路我拆开考虑最低位，两种都行，但是下面的方法不用多额外维护一个变量。

### 413
子问题f(k)定义为：A[1..k]中以最后一个元素结尾的等差数列的长度与公差还有最后一个元素的值。假设前面返回(l,d,a)意味着前面有一个公差是d的以最后一个元素结尾的l个元素构成等差slice。那么通过判断第k+1个元素与子问题返回的上一个元素的值的差，可以简单的更新子问题。注意的是本来我想写一个子函数求解子问题的，但是后来发现完全没有必要，子问题就是一个递推公式。
然后看答案，发现答案给了六种方案，暴力求解给了两种方法，一个O(n^3)的O(n^2)的，然后给了一个递归方法我没看。后面的三种都是基于动态规划的，各有小幅改进。他的方法好的地方是观察到，子问题“以当前元素为结尾的最长等差数列长度”一定是先是递增1，然后突然变成1，利用这个规律，可以减少更新总等差slice的次数，不用每次都更新，只在等差slice断裂，子问题答案为1时更新。但是不好的地方是他的做法每次都要回溯三个元素，我只需要回溯一个，但是我多维护了一个变量就是公差。
然后这个就很像回文子串总数那道题，最朴素的思路是三次方，好一点的暴力求解就是平方(利用串的规律：回文子串两边加上同样的字符还是回文，等差数列后面加上一个还是等差)，这样就可以变成平方时间效率，然后基于动态规划的扫描是常数时间效率。

### 647 *bangbang*
最长回文串的变形问题

最长回文子串直观的想那就是三次方时间效率，拿出所有的子串是平方，判断是不是回文是线性，总的就是三次方。好一点的方式就是扩张的方式检查回文串，遍历所有的对称轴是线性，判断此对称轴下的最长回文串是线性，总和是平方。马拉车算法的时间效率提高到了线性。依靠的就是问题巧妙的预处理和子问题的定义，定义f(k)是以k为轴的回文串的最大长度，并缓存前面所有的子问题的解，那么知道了这些了能不能推导出f(k+1)？后面就是马拉车的精髓了，利用了回文串的对称性，就不展开讲了。

注意的是，每次需要知道当前回文串最右延伸到哪里，实际上就是求前面子问题的最优解，这个不要每次遍历，要缓存，要记牢！！

通过马拉车得到一个字符串的所有子问题的解数组之后，能很快的用线性时间将其转化成回文子串总数，因为如果一个回文串的半径是r，我们就知道了以该点为对称轴的共有多少子串了。

但是实现上我实现的基于马拉车的算法咋还没有solution里面平方级别的算法快！后来我看了一下

[最长回文子串——Manacher 算法](https://segmentfault.com/a/1190000003914228)
[Manacher算法](https://segmentfault.com/a/1190000008484167)
[最简便的找字符串中最长回文子串的方法是什么？](https://www.zhihu.com/question/40965749/answer/152396279)

### 712
整道题一打眼就是LCS问题的改版，而我看了一下，跑得快的程序还真的是用LCS套的，我是自己又提炼出了新的子问题和迭代公式，但是比最快的人还要慢很多，我估摸着原因在于for循环和python自带函数的问题，我是一开始用for循环为dp数组边界赋值，使用LCS算法的需要用sum对两个字符串的所有字符的ascii值求和，然后减去最长公共子串的ascii的和，按理说都是两遍线性操作，但是人家就是快。

之前一直提醒自己用emuerate，这里不就是用这个的最好的地方吗，一旦想到是循环索引还是循环元素的时候，立刻用enumerate。

看到了参考文章：
[python提高效率的心得总结](https://www.cnblogs.com/yd1227/archive/2010/11/23/1885464.html)

### 646 *Greedy*
读完题，明显的区间调度问题，没跑。但是并没有什么乱用，我并不记得区间调度问题。

然后自己琢磨套路。
我开始想的子问题是截止到时间k，最多能排多少个任务（当成任务调度来看）。这种想法有一个弊端，假设在任务分布时间在1000内，但是200到800之间没有任务，那么中间的子问题是没有必要的。更清楚地说，只有任务的开始节点和结束节点考虑子问题有必要。
再进一步，任务的开始点有必要吗，会改变子问题的解吗？我觉得不会，只有开到任务的结束点我才可能确定去安排一个新的任务，那开始点有什么用？后面说。
那么直观的思路（自己画个图更清晰），两个重要的点：首先我必须以结束点作为键排序，然后就是两个相同结束点的任务，我选择开始晚的一定更好，那么其实我就可以不考虑同一个结束点但是开始较早的任务了。
然后遍历本次任务开始点之前的结束点，看看有没有更好的子问题的解，如果有设为那个解+1（因为当前任务也要做）。最后找子问题的解的最大值。这就能看明白了，子问题的意义是做了以这个点结束的任务（后面的不做了）时，我能做的最大任务数。这个思路应该是平方时间效率，提交之后500ms网上，开头排序就设置了nlogn的下限，然后每次遍历前面的子问题，
然后优化的话我先想到的优化点是每次都要遍历前面的子问题。如果我把子问题抽象为截止到当前时间点我能做的最多的任务数，其实我就看两个问题就行，一个是当前任务结束到当前任务开始的最晚结束的子问题的解，其实就是上一个子问题的解a(没有这样的人物话，a=0)，另一个就是开始点之前最晚结束子问题的解b，本次子问题的值就是max(a，b+1)

然后我看了solution。。。虽然也是给了平方时间效率的动规和nlogn的Greedy，但是差距咋这么大么。。

这个问题本科其实学过。。贪心算法第一个讲的就是这个。
调度问题可能需要研究研究。

这个我觉得可以抽象出一类DP算法中经常遇到的问题，就是假设子问题f(k)中的k是一个一个递增的话，我们从k=0开始一个一个向上算，只要一个字问题只依赖于前面的子问题就可以，但是假设k不是一个一个递增的，假设k是正整数，可以当前子问题中k=10,下一个子问题k=100了，怎么利用常数空间来做？更甚者，假设k是一个非inc的元素构成的向量呢？

[python二分查找与bisect模块](http://python.jobbole.com/86609/)

### 343 *Greedy* *bangbang*

子问题是f(k)，k=n是可以求解原问题最优解，求f(k+1)时，我们要做的就是从2~(k+1)/2中拆出一部分求解两个子问题的乘积，然后找到最大的子问题拆法，这里可能有疑问，就是我可能拆出大于等于2的因子啊，为什么子问题只需要拆成两个？这里就是DP的核心了，就是我只需要考虑子结构最优即可，我只需要把k拆成k1和k2两部分，至于这两部分是不是需要继续拆我交给子问题解决，当前问题我只考虑两部分怎么拆。这样一来思路就明确了，平方。

注意边界条件，题目要求至少分成两个整数，所以n=2或3的时候作为特例处理，返回n-1

但是这个又是一个贪心问题，就是尽可能地拆成2或3，理由需要数学证明，即我把一个数n拆成相等的k份，每份都是整数x，使x^k最大的时候x等于e，2和3是最靠近e的数，3又更靠近一些，所以优先选择3，其次是2。

参考：[wyh factor 2 or 3](https://leetcode.com/problems/integer-break/discuss/80721/Why-factor-2-or-3-The-math-behind-this-problem)

### 0/1背包问题

不需要按照单价排序的。
参考《算法十八讲》

### 72

实现了线性空间的搜索，但是怎么回溯还没有实现。

参考《算法十八讲》
参考 [编辑距离，拼写检查与度量空间](www.matrix67.com/blog/archives/333)



### 10
[TODO]

### 357


### 638 Shopping Offers
这道题启发我的入手点是把它当做背包问题，只能使用第一个special，然后推只能使用第二个special时的最小花费。
思路是完全背包问题，因为offer可以重复使用，去计算使用这个offer获得的收益。
递推思路是，如果使用这个offer的套餐不超过我现在的需求，且套餐比单买划算，我就有两种策略，要么使用这个special，然后降低我的需求，然后考虑继续使用这个special的子问题，要么直接放弃这个specal，不改变需求，直接看下一个special。
这个思路我觉得还行，看我代码中给的一个别人写的dfs的思路我觉得也特别好，也容易懂。



### 486 Predict The Winner
首先要理解题意：在博弈过程中每个人都会做出最佳决策的情况下，先手能否胜出？
划分子问题：长度为1的串先手肯定能赢（这个作为特例，不用求解子问题，作为子问题也可以，不过浪费一点点时间，我是将长度为2的串作为基本子问题），长度为2的串也肯定能赢，但是只知道能赢是不能将子问题连接到一起的，实际上思路是这样的，我拿长度为k的字串的头元素为尾元素，然后对手去拿剩下的串构成的子问题的最优解，只要我拿的这个元素比对手的k-1的子问题的答案大就行，那么我要做的就是比较我拿左侧元素和最右侧元素两种策略选取最优即可。总的解题过程就是自底向上填一个三角矩阵。
渐进复杂度是n^2

### 650 2 Keys Keyboard [Greedy]
A : None
2A : CV
3A  : CVV
4A  : 2*2 -> CV + CV
    : 1*4 -> CVVV
5A  : 1*5 -> CVVVV
6A  : 2*3 -> CV + CVV
    : 3*2 -> CVV + CV
    : 1*6 -> CVVVVV
7A  : 1*7 -> CVVVVVV
8A  : 1*8 -> CVVVVVVV
    : 2*4 -> CV + CVVV
    : 4*2 -> CVCV + CV
12A : 1*12 -> 12
    : 3*4 -> 3 + 4
    : 4*3 -> 4 + 3
    : 2*6 -> 2 + 6
    : 6*2 -> 5 + 2
14A : 1*14 -> 14
    : 2*7 -> 2 + 7
    : 7*2 -> 7 + 2
24A : 1*24 -> 24
    : 2*12 -> 2 + 12
    : 3*8 -> 3 + 8
    : 4*6 -> 4 + 6
    : 6*4 -> 5 + 4
    : 8*3 -> 6 + 3
    : 12*2 -> 7 + 2
42A : 1*42 -> 42
    : 3*14 -> 3 + 14
    : 14*3 -> 9 + 3
    : 6*7 -> 5 + 7
    : 7*6 -> 7 + 6
递归的思路已经出来了，接下来就是效率的问题。
首先，只要能分解，肯定比不分解好，只要能拆成两个数大于1的因子，那么这两个因子的和肯定小于原来的数。（易证）
再有，如果能拆成两个因子a和b，而且a大于b，那么拆成<a,b>一定比<b,a>好，因为后面的数是重复，重复的话一定是C加上一串V，但是前面的数已经是解决过的最优子问题了，很有可能小，但是怎么着也不会更差。然后仔细一想，不对！大的数不一定最优子问题就比小的数的最优子问题更好，比如大的数是质数，就像42拆分成6和7。

但是我这种方法的效率很低，是n^2的效率，这道题实际上可以转化为贪心，Solution中时间最短那那个提交就是。
他的方法实际上基于一个观察，这道题等价为将一个纸带不停的折叠，但是每次折叠的长度必须是整数，因此实际上就是做因式分解，将所有质数相加即可。

### 120 Triangle
这道题比较简单，子问题都不用思考，O(n^2)的时间效率，O(n)的空间效率。

### 62 Unique Path
这道题比较简单，可以转化为组合数问题，使用scipy.special.comb比较慢，自己实现DP解法，空间代价是O(min(m,n)),时间代价是O(mn)，子问题就是到某一个点的路径数

### 494 Target Sum
简单的思路就是用深度递归，去掉最后一个元素，并且改变目标，然后求解子问题。进行了一点优化是预先求出累加和，如果目标值大于累加和，直接返回0。但是超时了，然后加上memoization技巧，成功AC。
但是Solution中的DP解法没太明白，但是看了Discuss中的排名最高的那个解法，倒是理解了，十分巧妙，通过一点简单的推理，将该问题转化为背包问题的变体。即从拥有各自价值的一堆物品中，选出恰好为某价值的物品的选法总数。
转化DP传统的二维表思路，子问题就是"选择前i个物品，使总价值是w的选择方法数"。递推公式是dp[i][w]=dp[i-1][w]+dp[i-1][w-wi]，就是选不选当前物品这两种可能性。然后Discuss的实现中有两处优化，一是空间缩减为线性，这样就需要对价值倒序更新，因为我们需要的是i-1的dp。其次就是对于价值小于本次物品价值的dp不予更新。
都在《背包九讲》中提到过，还是基础更重要。

### 64 Minimum Path Sum
很简单的题目，类似62。

### 392 Is Subsequence
双序列问题，比较简单。注意的一点是明确一下子问题，表达出来：s的前i位和t的前j位是否匹配。递推关系时，如果最后一位一样，尝试两者一起前移一位，缩小问题规模，如果失败或者不一样，只把长串前移一位。
跑的时候发现这样效率特别低，比如asd匹配asdqqqqqqqqqqqqqq，就要一直匹配q，然而我们知道需要的是d，所以最后一位不同的时候，直接在长串中去找到d再进行递归。
继续琢磨的话可以更快，比如asddd匹配asdddddddd，我们可以直接在后面找最靠左的ddd，然后缩减子问题，但是这个想法我没试，不知道对不对……

### 121 Best Time to Buy and Sell Stock
没有找到明显的动态规划的问题，也就是有一个递推公式，应该不算DP吧。

不过讨论区提到了一个十分巧妙的思路，类似于Kadane算法。真的很牛逼。思路类似于求一个F(b)-F(a)等价于计算f(x)在区间[a,b]上的积分。

但是我的思路也不赖，重点是抽象出子问题形式，53题的子问题f(k)解决的是以第k个元素结尾的最大连续子数组，那么这道题的子问题f(k)我抽象成为以第k个元素为价格售出可以获得的最大收益。如果这样，还是会产生子问题之间的递归断裂的问题，比如考虑f(2),[1,5]和[5,9]都会返回4，但是假设第三个元素是6，那么f(3)是可能是5或者1。因此子问题还需要返回更多的信息，我们让子问题f(k)返回第k个元素为价格售出的情况下的购买价格和售出价格就可以了。还是前面的小例子，对于[1,5]返回(1,5)，对于[5,9]返回(5,9)，那么接下来的元素遇到6，f(3)分别更新为(1,6)和(5,6)，没毛病老铁。更具体的说，f(k)返回值是(数组前k各元素的最小值，A[k])

## 买卖股票系列

### 714 Best Time to Buy and Sell Stock with Transaction Fee *bangbang*

这道题我和solution不大一样，子问题我设置为，截止到当前的最大值和最小值，但是这样的话立刻就会有疑问：最大值出现在最小值之前怎么办。这个其实先明确子问题的更新方法后就可以证明不会出现这种情况，更新方法就是一旦今天的价格比之前的最大值低fee还要多，那我就立刻清算之前的交易，然后加到我总的盈利里面，然后以今天的价格同时替代最大值最小值。不然就正常的更新最大值最小值。这里的合理性写一个小等式就可以证明，设置最大值为a，最小值为b，当前价格为p，后面的又一个峰值是x，然后列不等式就行。

至于前面提到的最大值出现在最小值后面的情况，因为我们一定是最大值比最小值加上交易费还要多我们才会交易，然后假设真的有这样的最小值出现在最大值后面，我们不会直接把最小值更新，而是会先结算之前的交易，实际上这次的最小值就已经不被之前考虑了。

但是可以看一下给的标准答案，思路真的清晰简洁。就是当前有两种状态，要么手里有股票，要么没有股票，那么就同时维护这两种可能的状态，有新的价格的时候，更新有股票的状态为：max（持股不动手中的现金数，买这次的股票现金减少），不持股的状态更新为：max（按兵不动，卖出并支付手续费）

### 309 Best Time to Buy and Sell Stock with Cooldown
有了714的基础，这道题很好解决，就是多保存一天的状态，思路和之前的一道DP题，说小偷不能连续偷两家很像。

### 688 Knight Probability in Chessboard
这道题我感觉我并没有用到DP的方法，也就是memoization trick用到了，更像是DFS，但是也是过了，估计是整个leetcode最慢的了。。。看一看Solution中的DP方法，很DP了，不断地更新矩阵，没仔细看，先马后看（吗）。。


### 474 Ones and Zeros [Greedy]
我把这道题转化为一个二维多重背包问题，就好解了，但是提交之后发现竟然有更快的。看了一下代码，发现更快的是用了贪心，贪心的大概思路明白了，我把我的想法写在了代码StandardSolution类的注释里，但是正确性证明我不懂，不知道为什么这样可以。目前的感觉在于一个原因是所有的物品价值相同。

### 740 Delete and Earn
还是问题的转化，首先意识到这道题元素的位置不重要，重要的是元素的值，因为一下子会把所有的相邻值的元素全部删除而不管元素在哪里。所以要转化为不同的元素的值与其出现次数的一个元组列表。其次排序也是必须的，这个比较好想，因为为了决定子问题，要看子问题的中是否存在需要删除的相邻元素，排序后这个问题只需要看上一个元素是否相邻。问题转化到这里已经是基础一维动归问题了：即小偷问题。
只是还有一点区别：这里的小偷不是相邻的一定不偷，而是会考察元素的值，如果相邻的元素的值的差大于1，那么相邻的也偷，所以子问题递推的时候根据上一个元素分情况讨论就可以。

### 312 Burst Balloons
第一次尝试没有写出来，尝试了线性的DP，感觉不太可能，要是抽象成树形解空间感觉可以用Memoization或者backtrack来解，但是没有编码。

### 5 Longest Palindromic Substring
经过647的考验，这道题应该立刻想到manachers算法，可惜我没有立刻想到，我反映了一下，还尝试自己解，然后没想到好方法，才想到了马拉车。想到马拉车就好办了，我直接把647Solution里面的子函数拿过来用了，不过我也不知道之前咋想的，马拉车里面dp数组存放的是回文串半径，但是我写的马拉车的半径不算中心元素。。。

### 516 Longest Palindromic Subsequence *bangbang*
[Solution](https://leetcode.com/problems/longest-palindromic-subsequence/discuss/99101/Straight-forward-Java-DP-solution)

### 96 Unique Binary Search Trees
由于树自身的递推结构，直接去退递推关系一点毛病也没有。递推关系式得到之后发现并不是以来常数个子问题，而是依赖前面所有的子问题，这一点和277基本如出一辙，唯一不同的就是怎么利用前面的子问题的解上。这样的问题应该可以归为一类：无限制单序列DP问题。这类问题需要线性时间线性空间，与之类似的是限制型单序列DP问题，如斐波那契数列的求解，这种问题需要常数空间线性时间。

### 718	Maximum Length of Repeated Subarray
一下子就想到的最长子串匹配，但是不可能这么简单，仔细一看，啊！要求连续子串！连续性问题在前面的单个数组想好多问题中都见过了，这里一样，设置一个历史最大值，然后DP只处理当前连续的子问题解，并对最大值进行维护就行。但是这样得到的效率是MN。Solution给出了一种基于Rabin-Karp算法的解决方案，效率是O((M+N)∗log(min(M,N)))，这种灵性的解法估计想不出来，就这么看看吧。。

[图说Rabin-Karp字符串查找算法](http://www.ituring.com.cn/article/1759)

### 813 Largest Sum of Average [bangbang]
序列切分问题，是不是可以引出一类问题？
核心思想是前i个元素分成k个的最优解，依赖于前j个元素分成k-1份的子问题的最优解，其中j是所有大于k-1小于i的整数。
用官方example举例来说，【9,1,2,3,9】分成3份的最优解来自于这么几个字问题：
	【9,1,2,3】分成两份的最优解 + average（9）
	【9,1,2】分成两份的最优解 + average（3,9）
	【9,1】分成两份的最优解 + average（2,3,9）

### 300 Longest Increasing Subsequence [bangbang]
很不错的题，我开始的思路是就是先找递推关系，比如subQ[1,3,6,7,9,4,10,5,6]可以约减为[1,3,6,7,9,4,10,5]+1，subQ[1,3,6,7,9,4,10,5]就要分情况了，一种是[1,3,6,7,9,4]+1，一种是[1,3,6,7,9,4,10]，因为选了最后的5的话，倒数第二个10肯定要不了了，要么就是先不要5，看看选更大的10会不会带来更大的收益。然后[1,3,6,7,9,4,10]可以直接约减为[1,3,6,7,9,4]+1，此时已经出现重复子问题了，可以用DP做。
上面是反着思考，然后要正着写代码，思路就和我的实现一样，从前面所有的子问题中选可以和当前元素构成新的递增序列的子问题的解的最大值，如果没有就赋值1。DP数组的意义就是“以当前元素结尾的递增子序列最长可以多长”，然后返回DP中的最大值就行。

上面这个思路没问题，本来也可以结束了，但是题目下面问可不可以用nlogn来解决，现在的解法是n^2的时间效率。现在的DP数组肯定是nlogn不了，我直接看的答案。
重点是构建有序的DP，这样就可以用二分搜索了，但是我死活也是没能自己想出来。。。
新的DP[i]表示长度为i+1的递增序列末尾元素最小是多少，最后DP的长度就是答案。logn出现在DP是有序数组，在更新DP的时候可以二分搜索。

[Java/Python Binary search O(nlogn) time with explanation](https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation)
[leetcode（300）—— Longest Increasing Subsequence（最长递增子序列）](https://blog.csdn.net/lanchunhui/article/details/51611970)

---
1. [什么是动态规划？动态规划的意义是什么？](https://www.zhihu.com/question/23995189)
2. [非常好的动态规划总结，DP总结](https://blog.csdn.net/mmc2015/article/details/73558346)
3. [背包问题九讲](https://github.com/tianyicui/pack)
