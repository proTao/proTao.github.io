<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Why Python is Slow:Looking Under the Hood | proTao的大脑具现</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="翻译自Why Python is Slow: Looking Under the Hood 我们以前都听说过 : Python很慢。 当我在Python上讲授关于科学计算的课程时，我在课程的早期就提出了这个观点，并告诉学生们为什么:它归结为Python是一种动态类型的解释语言，它的值不是存储在密集的缓冲区中，而是存储在分散的对象中。然后我将讨论如何通过使用NumPy、SciPy和相关工具对操作进行">
<meta name="keywords" content="python,translation">
<meta property="og:type" content="article">
<meta property="og:title" content="Why Python is Slow:Looking Under the Hood">
<meta property="og:url" content="https://protao.github.io/2018/06/30/Python-2018-06-30-WhyPythonisSlow/index.html">
<meta property="og:site_name" content="proTao的大脑具现">
<meta property="og:description" content="翻译自Why Python is Slow: Looking Under the Hood 我们以前都听说过 : Python很慢。 当我在Python上讲授关于科学计算的课程时，我在课程的早期就提出了这个观点，并告诉学生们为什么:它归结为Python是一种动态类型的解释语言，它的值不是存储在密集的缓冲区中，而是存储在分散的对象中。然后我将讨论如何通过使用NumPy、SciPy和相关工具对操作进行">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://jakevdp.github.io/images/cint_vs_pyint.png">
<meta property="og:image" content="http://jakevdp.github.io/images/array_vs_list.png">
<meta property="og:image" content="https://protao.github.io/2018/06/30/img/why_python_is_slow3.png">
<meta property="og:updated_time" content="2018-07-24T12:11:19.515Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Why Python is Slow:Looking Under the Hood">
<meta name="twitter:description" content="翻译自Why Python is Slow: Looking Under the Hood 我们以前都听说过 : Python很慢。 当我在Python上讲授关于科学计算的课程时，我在课程的早期就提出了这个观点，并告诉学生们为什么:它归结为Python是一种动态类型的解释语言，它的值不是存储在密集的缓冲区中，而是存储在分散的对象中。然后我将讨论如何通过使用NumPy、SciPy和相关工具对操作进行">
<meta name="twitter:image" content="http://jakevdp.github.io/images/cint_vs_pyint.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="../../../../css/style.css">
  <meta name="baidu-site-verification" content="xerEdoxBbf">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['\\(','\\)'],['$$$','$$$'],['$','$']]}
});
</script>
<script type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="../../../../index.html" id="logo">proTao的大脑具现</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="../../../../index.html">home</a>
        
          <a class="main-nav-link" href="../../../../archives">archives</a>
        
          <a class="main-nav-link" href="../../../../about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://protao.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">

<article id="post-Python-2018-06-30-WhyPythonisSlow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2018-06-29T16:00:00.000Z" itemprop="datePublished">2018-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="../../../../categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Why Python is Slow:Looking Under the Hood
    </h1>
  
 
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>翻译自<a href="https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/" target="_blank" rel="noopener">Why Python is Slow: Looking Under the Hood</a></strong></p>
<p>我们以前都听说过 : Python很慢。</p>
<p>当我在Python上讲授关于科学计算的课程时，我在课程的早期就提出了这个观点，并告诉学生们为什么:它归结为Python是一种动态类型的解释语言，它的值不是存储在密集的缓冲区中，而是存储在分散的对象中。然后我将讨论如何通过使用NumPy、SciPy和相关工具对操作进行矢量化并调用到编译后的代码，然后继续。</p>
<p>但最近我意识到一些事情:尽管上面的陈述相对准确，“动态类型-解释-缓存-向量-编译”这个词对参加入门编程研讨会的人来说可能没什么意义。可以说，这些术语并不能让人们了解“幕后”到底在发生什么。</p>
<p>所以我决定写这篇文章，深入研究我经常忽略的细节。在此过程中，我们将研究如何使用Python的标准库来反思CPython本身的问题。因此，无论您是新手还是经验丰富的程序员，我希望您能从下面的探索中学到一些东西。</p>
<a id="more"></a>
<h2 id="Why-Python-is-Slow¶"><a href="#Why-Python-is-Slow¶" class="headerlink" title="Why Python is Slow¶"></a>Why Python is Slow<a href="#Why-Python-is-Slow">¶</a></h2><p>由于各种原因，Python比Fortran和C慢:</p>
<h3 id="1-Python-is-Dynamically-Typed-rather-than-Statically-Typed-¶"><a href="#1-Python-is-Dynamically-Typed-rather-than-Statically-Typed-¶" class="headerlink" title="1. Python is Dynamically Typed rather than Statically Typed.¶"></a>1. <strong>Python is Dynamically Typed rather than Statically Typed</strong>.<a href="#1.-Python-is-Dynamically-Typed-rather-than-Statically-Typed.">¶</a></h3><p>这意味着在程序执行时，解释器不知道所定义的变量的类型。C变量(我使用C作为编译语言的替代)和Python变量之间的区别如下图所示:</p>
<p><img src="http://jakevdp.github.io/images/cint_vs_pyint.png" alt="cint vs pyint"></p>
<p>对于C中的一个变量，编译器通过它的定义知道类型。对于Python中的一个变量，当程序执行时，您只知道它是某种Python对象。</p>
<p>如果你用C来写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure>
<p>C编译器从一开始就知道<code>a</code>和<code>b</code>是整数:它们不可能是别的东西!有了这些知识，它就可以调用增加两个整数的例程，返回内存中的一个简单值的另一个整数。作为一个粗略的示意图，事件的顺序如下:</p>
<h4 id="C-Addition¶"><a href="#C-Addition¶" class="headerlink" title="C Addition¶"></a>C Addition<a href="#C-Addition">¶</a></h4><ol>
<li>Assign <code>&lt;int&gt; 1</code> to <code>a</code></li>
<li>Assign <code>&lt;int&gt; 2</code> to <code>b</code></li>
<li>call <code>binary_add&lt;int, int&gt;(a, b)</code></li>
<li>Assign the result to c</li>
</ol>
<p>Python中的等效代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure></p>
<p>在这里，解释器只知道<code>1</code>和<code>2</code>是对象，而不知道它们是什么类型的对象。因此，解释器必须检查每个变量的<code>PyObject_HEAD</code>以查找类型信息，然后为这两种类型调用适当的求和例程。最后，它必须创建并初始化一个新的Python对象来保存返回值。事件的顺序大致如下:</p>
<h4 id="Python-Addition¶"><a href="#Python-Addition¶" class="headerlink" title="Python Addition¶"></a>Python Addition<a href="#Python-Addition">¶</a></h4><ol>
<li><p>Assign <code>1</code> to <code>a</code></p>
<ul>
<li><strong>1a.</strong> Set <code>a-&gt;PyObject_HEAD-&gt;typecode</code> to integer</li>
<li><strong>1b.</strong> Set <code>a-&gt;val = 1</code></li>
</ul>
</li>
<li><p>Assign <code>2</code> to <code>b</code></p>
<ul>
<li><strong>2a.</strong> Set <code>b-&gt;PyObject_HEAD-&gt;typecode</code> to integer</li>
<li><strong>2b.</strong> Set <code>b-&gt;val = 2</code></li>
</ul>
</li>
<li><p>call <code>binary_add(a, b)</code></p>
<ul>
<li><strong>3a.</strong> find typecode in <code>a-&gt;PyObject_HEAD</code></li>
<li><strong>3b.</strong> <code>a</code> is an integer; value is <code>a-&gt;val</code></li>
<li><strong>3c.</strong> find typecode in <code>b-&gt;PyObject_HEAD</code></li>
<li><strong>3d.</strong> <code>b</code> is an integer; value is <code>b-&gt;val</code></li>
<li><strong>3e.</strong> call <code>binary_add&lt;int, int&gt;(a-&gt;val, b-&gt;val)</code></li>
<li><strong>3f.</strong> result of this is <code>result</code>, and is an integer.</li>
</ul>
</li>
<li><p>Create a Python object <code>c</code></p>
<ul>
<li><strong>4a.</strong> set <code>c-&gt;PyObject_HEAD-&gt;typecode</code> to integer</li>
<li><strong>4b.</strong> set <code>c-&gt;val</code> to <code>result</code></li>
</ul>
</li>
</ol>
<p>动态类型意味着与任何操作相关的步骤要多得多。这是Python在对数值数据进行操作时比C慢的主要原因。</p>
<h3 id="2-Python-is-interpreted-rather-than-compiled-¶"><a href="#2-Python-is-interpreted-rather-than-compiled-¶" class="headerlink" title="2. Python is interpreted rather than compiled.¶"></a>2. Python is interpreted rather than compiled.<a href="#2.-Python-is-interpreted-rather-than-compiled.">¶</a></h3><p>上面我们看到了解释代码和编译代码之间的一个区别。一个聪明的编译器可以预测和优化重复或不需要的操作，这会导致加速。编译器优化是它自己的野兽，我个人没有资格说太多，所以我就讲到这里。关于这方面的一些实际例子，您可以查看我在Numba和Cython上的<a href="http://jakevdp.github.io/blog3/06/15 / Numba -vs- Cython -take-2/" target="_blank" rel="noopener">之前的文章</a>。</p>
<h3 id="3-Python’s-object-model-can-lead-to-inefficient-memory-access¶"><a href="#3-Python’s-object-model-can-lead-to-inefficient-memory-access¶" class="headerlink" title="3. Python’s object model can lead to inefficient memory access¶"></a>3. Python’s object model can lead to inefficient memory access<a href="#3.-Python&#39;s-object-model-can-lead-to-inefficient-memory-access">¶</a></h3><p>我们在上面看到了从C整数转移到Python整数的额外类型信息层。现在假设有许多这样的整数，并希望对它们执行某种批处理操作。在Python中，您可能使用标准的“List”对象，而在C中，您可能使用某种基于缓冲的数组。</p>
<p>以最简单的形式表示的NumPy数组是围绕C数组构建的Python对象。也就是说，它有一个指向_contiguous_data值缓冲区的指针。另一方面，Python列表有一个指向指针的连续缓冲区的指针，每个指针指向一个Python对象，而这个对象又引用了它的数据(在本例中是整数)。这是两幅图的示意图</p>
<p><img src="http://jakevdp.github.io/images/array_vs_list.png" alt="数组和列表"></p>
<p>很容易看出，如果您正在执行按顺序处理数据的操作，那么numpy布局在存储成本和访问成本方面将比Python布局高效得多。</p>
<h3 id="So-Why-Use-Python-¶"><a href="#So-Why-Use-Python-¶" class="headerlink" title="So Why Use Python?¶"></a>So Why Use Python?<a href="#So-Why-Use-Python?">¶</a></h3><p>考虑到这种固有的低效率，我们为什么还要考虑使用Python呢?好吧，它可以归结为:动态类型使Python比C<strong>更容易使用</strong>，它非常<strong>灵活和宽容</strong>，这种灵活性导致了<strong>高效地使用开发时间</strong>，在那些您确实需要优化C或Fortran的情况下，<strong>Python提供了编译库</strong>的简单挂钩。这就是为什么Python在许多科学社区中的使用一直在不断增长。结合所有这些，Python最终成为一种非常高效的语言，用于完成使用代码进行科学研究的总体任务。</p>
<h2 id="Python-meta-hacking-Don’t-take-my-word-for-it¶"><a href="#Python-meta-hacking-Don’t-take-my-word-for-it¶" class="headerlink" title="Python meta-hacking: Don’t take my word for it¶"></a>Python meta-hacking: Don’t take my word for it<a href="#Python-meta-hacking:-Don&#39;t-take-my-word-for-it">¶</a></h2><p>上面我已经讨论了一些内部结构，这些结构使得Python能够正常工作，但是我不想就此打住。在整理上述总结时，我开始深入研究Python语言的内部原理，并发现该过程本身非常具有启发性。</p>
<p>在接下来的几节中，我将通过使用Python本身来公开Python对象来验证上述信息的正确性。请注意，以下内容都是使用<strong>Python 3.4</strong>编写的。早期的Python版本具有稍微不同的内部对象结构，而后来的版本可能会进一步调整这种结构。请务必使用正确的版本!此外，下面的大多数代码都假设有一个64位CPU。如果您在一个32位的平台上，下面的一些C类型将不得不进行调整以解释这种差异。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(<span class="string">"Python version ="</span>, sys.version[:<span class="number">5</span>]) <span class="comment"># Python version = 3.4.0</span></span><br></pre></td></tr></table></figure>
<h3 id="Digging-into-Python-Integers¶"><a href="#Digging-into-Python-Integers¶" class="headerlink" title="Digging into Python Integers¶"></a>Digging into Python Integers<a href="#Digging-into-Python-Integers">¶</a></h3><p>Integers in Python are easy to create and use:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">42</span></span><br><span class="line">print(x) <span class="comment"># 42</span></span><br></pre></td></tr></table></figure>
<p>但是这个接口的简单性掩盖了在后台发生的事情的复杂性。我们简要地讨论了上面Python整数的内存布局。在这里，我们将使用Python的内置“ctypes”模块从Python解释器本身内省出Python的整数类型。但是首先我们需要知道Python整数在C API级别上的样子。</p>
<p>CPython中的实际“x”变量存储在CPython源代码中定义的结构中，在<a href="http://hg.python.org/cpython/file/3.4/Include/longintrepr.h/#l89" target="_blank" rel="noopener">Include/longintrepr.h</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>PyObject_VAR_HEAD</code>是一个宏，它以以下结构启动对象，在<a href="http://hg.python.org/cpython/file/3.4/Include/object.h#l111" target="_blank" rel="noopener">Include/object.h</a>中定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>
<p>…这里又包含一个<code>PyObject</code>元素，它也在<a href="http://hg.python.org/cpython/file/3.4 include/object.h l105" target="_blank" rel="noopener">Include/object.h</a>中定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
<p>这里的<code>_PyObject_HEAD_EXTRA</code>是一个宏，在Python构建中通常不使用这个宏。</p>
<p>将所有这些组合在一起，并没有混淆typedefs/macros，我们的integer对象就会得到如下结构:</p>
<p>struct _longobject {<br>    long ob_refcnt;<br>    PyTypeObject *ob_type;<br>    size_t ob_size;<br>    long ob_digit[1];<br>};</p>
<p><code>ob_refcnt</code>变量是对象的引用计数，<code>ob_type</code>变量是指向包含对象的所有类型信息和方法定义的结构的指针，<code>ob_digit</code>包含实际的数值。</p>
<p>有了这些知识，我们将使用<code>ctypes</code>模块开始研究实际的对象结构并提取上面的一些信息。</p>
<p>我们首先定义C结构的Python表示形式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntStruct</span><span class="params">(ctypes.Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"ob_refcnt"</span>, ctypes.c_long),</span><br><span class="line">                (<span class="string">"ob_type"</span>, ctypes.c_void_p),</span><br><span class="line">                (<span class="string">"ob_size"</span>, ctypes.c_ulong),</span><br><span class="line">                (<span class="string">"ob_digit"</span>, ctypes.c_long)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"IntStruct(ob_digit=&#123;self.ob_digit&#125;, "</span></span><br><span class="line">                <span class="string">"refcount=&#123;self.ob_refcnt&#125;)"</span>).format(self=self)</span><br></pre></td></tr></table></figure>
<p>现在我们来看看某个数的内部表示，比如42。我们将使用在CPython中，<code>id</code>函数给出对象的内存位置:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">42</span></span><br><span class="line">IntStruct.from_address(id(<span class="number">42</span>)) <span class="comment"># IntStruct(ob_digit=42, refcount=35)</span></span><br></pre></td></tr></table></figure>
<p>“ob_digit”属性指向内存中的正确位置!</p>
<p>但是“refcount”呢?我们只创建了一个值:为什么引用计数要比1大得多?</p>
<p>原来Python中大量使用小整数。如果为每一个整数创建一个新的<code>PyObject</code>，将需要大量内存。正因为如此，Python实现了公共整数对象缓冲池，里面的对象实现了<code>单例模式</code>:也就是说，内存中只有这些数字的一个副本。换句话说，每当您在这个范围内创建一个新的Python整数时，您只是创建一个具有该值的单例对象的引用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">42</span></span><br><span class="line">y = <span class="number">42</span></span><br><span class="line">id(x) == id(y) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>两个变量都是指向相同内存地址的指针。当您得到更大的整数(在Python 3.4中大于255)时，这就不再成立:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1234</span></span><br><span class="line">y = <span class="number">1234</span></span><br><span class="line">id(x) == id(y) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>只要启动Python解释器，就会创建许多整型对象;看看每个对象有多少引用计数是很有趣的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">plt.loglog(range(<span class="number">1000</span>), \[sys.getrefcount(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)\])</span><br><span class="line">plt.xlabel(<span class="string">'integer value'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'reference count'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="../img/why_python_is_slow3.png" alt></p>
<p>我们看到，0被引用了数千次，正如您所期望的，引用的频率通常随着整数的值的增加而降低。</p>
<p>为了进一步确保这是我们所期望的，让我们确保<code>ob_digit</code>字段保持正确的值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all(i == IntStruct.from_address(id(i)).ob_digit</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)) <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<p>如果再深入一点，您可能会注意到，这不适用于大于256的数字:事实证明，某些位移操作会在<a href="https://hg.python.org/cpython/file/3.4/Objects/longobject.c#l232" target="_blank" rel="noopener">Objects/longobject.c</a>中执行，这些改变了大整数在内存中的表示方式。</p>
<p>我不能说我完全理解为什么会发生这种情况，但我认为这与Python能够有效地处理超过长int数据类型溢出限制的整数有关，正如我们在这里看到的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">100</span> <span class="comment"># 1267650600228229401496703205376</span></span><br><span class="line"><span class="comment"># 2 ** 100</span></span><br></pre></td></tr></table></figure>
<p>这个数字太长以至于不能成为一个<code>long</code>,只能持有价值64位的值。</p>
<h3 id="Digging-into-Python-Lists¶"><a href="#Digging-into-Python-Lists¶" class="headerlink" title="Digging into Python Lists¶"></a>Digging into Python Lists<a href="#Digging-into-Python-Lists">¶</a></h3><p>让我们将上面的想法应用到更复杂的类型:Python列表。与整数类似，我们在<a href="http://hg.python.org/cpython/file/3.4/Include/listobject.h#l23" target="_blank" rel="noopener">Include/listobject.h</a>中找到列表对象本身的定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject\_VAR\_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py\_ssize\<span class="keyword">_t</span> allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure></p>
<p>同样，我们可以扩展宏并消除类型的混淆，以确保结构有效地如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">    Py\_ssize\<span class="keyword">_t</span> ob_size;</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    <span class="keyword">long</span> allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure>
<p>这里的<code></code>PyObject **ob_item<code>指向列表的内容，</code>ob_size`值告诉我们列表中有多少项。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListStruct</span><span class="params">(ctypes.Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"ob_refcnt"</span>, ctypes.c_long),</span><br><span class="line">                (<span class="string">"ob_type"</span>, ctypes.c_void_p),</span><br><span class="line">                (<span class="string">"ob_size"</span>, ctypes.c_ulong),</span><br><span class="line">                (<span class="string">"ob_item"</span>, ctypes.c_long),  <span class="comment"># PyObject** pointer cast to long</span></span><br><span class="line">                (<span class="string">"allocated"</span>, ctypes.c_ulong)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"ListStruct(len=&#123;self.ob_size&#125;, "</span></span><br><span class="line">                <span class="string">"refcount=&#123;self.ob_refcnt&#125;)"</span>).format(self=self)</span><br></pre></td></tr></table></figure>
<p>让我们试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = \[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>\]</span><br><span class="line">ListStruct.from_address(id(L)) <span class="comment"># ListStruct(len=5, refcount=1)</span></span><br></pre></td></tr></table></figure>
<p>为了确保我们已经正确地完成了任务，让我们在列表中创建一些额外的引用，并查看它如何影响引用计数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = \[L, L\]  \<span class="comment"># two more references to L</span></span><br><span class="line">ListStruct.from_address(id(L)) <span class="comment"># ListStruct(len=5, refcount=3)</span></span><br></pre></td></tr></table></figure>
<p>现在让我们看看如何在列表中找到实际的元素。</p>
<p>正如我们上面看到的，元素是通过<code>PyObject</code>指针的连续数组存储的。使用<code>ctypes</code>，我们实际上可以创建一个复合结构，其中包含我们以前的<code>IntStruct</code>对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get a raw pointer to our list</span></span><br><span class="line">Lstruct = ListStruct.from_address(id(L))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a type which is an array of integer pointers the same length as L</span></span><br><span class="line">PtrArray = Lstruct.ob_size * ctypes.POINTER(IntStruct)</span><br><span class="line"></span><br><span class="line"><span class="comment"># instantiate this type using the ob_item pointer</span></span><br><span class="line">L_values = PtrArray.from_address(Lstruct.ob_item)</span><br></pre></td></tr></table></figure>
<p>现在让我们看一下列表中每个元素的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ptr[<span class="number">0</span>] <span class="keyword">for</span> ptr <span class="keyword">in</span> L_values]  <span class="comment"># ptr[0] dereferences the pointer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># out</span></span><br><span class="line"><span class="comment">#[IntStruct(ob_digit=1, refcount=5296),</span></span><br><span class="line"><span class="comment"># IntStruct(ob_digit=2, refcount=2887),</span></span><br><span class="line"><span class="comment"># IntStruct(ob_digit=3, refcount=932),</span></span><br><span class="line"><span class="comment"># IntStruct(ob_digit=4, refcount=1049),</span></span><br><span class="line"><span class="comment"># IntStruct(ob_digit=5, refcount=808)]</span></span><br></pre></td></tr></table></figure>
<p>我们已经在列表中恢复了<code>PyObject</code> 整形! 您可能希望花点时间来回顾上面的列表内存布局的示意图，并确保您理解了这些<code>ctypes</code>操作是如何映射到该图表上的。</p>
<h3 id="Digging-into-NumPy-arrays¶"><a href="#Digging-into-NumPy-arrays¶" class="headerlink" title="Digging into NumPy arrays¶"></a>Digging into NumPy arrays<a href="#Digging-into-NumPy-arrays">¶</a></h3><p>现在，为了进行比较，让我们对numpy数组进行同样的自省。我将跳过NumPy C-API数组定义的详细介绍;如果您想查看它，可以在<a href="https://github.com/numpy/numpy/blob/maintenance/1.8.x/numpy/core/include/numpy/ndarraytypes.h#L646" target="_blank" rel="noopener">numpy/core/include/numpy/ndarraytypes.h</a>中找到它</p>
<p>注意，这里使用的是NumPy version 1.8;这些内部特性可能在不同版本之间发生了变化，尽管我不确定是否如此。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.__version__ <span class="comment"># '1.8.1'</span></span><br></pre></td></tr></table></figure>
<p>让我们首先创建一个表示numpy数组本身的结构。这应该开始看起来很熟悉了……</p>
<p>我们还将添加一些自定义属性来访问Python版本的形状和步骤:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumpyStruct</span><span class="params">(ctypes.Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"ob_refcnt"</span>, ctypes.c_long),</span><br><span class="line">                (<span class="string">"ob_type"</span>, ctypes.c_void_p),</span><br><span class="line">                (<span class="string">"ob_data"</span>, ctypes.c_long),  <span class="comment"># char* pointer cast to long</span></span><br><span class="line">                (<span class="string">"ob_ndim"</span>, ctypes.c_int),</span><br><span class="line">                (<span class="string">"ob_shape"</span>, ctypes.c_voidp),</span><br><span class="line">                (<span class="string">"ob_strides"</span>, ctypes.c_voidp)]</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shape</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple((self.ob_ndim * ctypes.c_int64).from_address(self.ob_shape))</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strides</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple((self.ob_ndim * ctypes.c_int64).from_address(self.ob_strides))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"NumpyStruct(shape=&#123;self.shape&#125;, "</span></span><br><span class="line">                <span class="string">"refcount=&#123;self.ob_refcnt&#125;)"</span>).format(self=self)</span><br></pre></td></tr></table></figure>
<p>现在我们来试试:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.random((<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">xstruct = NumpyStruct.from_address(id(x))</span><br><span class="line">xstruct <span class="comment"># NumpyStruct(shape=(10, 20), refcount=1)</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到了正确的形状信息。让我们确保参考数是正确的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [x,x,x]  <span class="comment"># add three more references to x</span></span><br><span class="line">xstruct <span class="comment"># NumpyStruct(shape=(10, 20), refcount=4)</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以把数据缓冲区取出来。为了简单起见，我们将忽略这个步骤，假设它是一个c连续数组;这可以通过一些工作来推广。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">xstruct = NumpyStruct.from_address(id(x))</span><br><span class="line">size = np.prod(xstruct.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># assume an array of integers</span></span><br><span class="line">arraytype = size * ctypes.c_long</span><br><span class="line">data = arraytype.from_address(xstruct.ob_data)</span><br><span class="line"></span><br><span class="line">[d <span class="keyword">for</span> d <span class="keyword">in</span> data]  <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p><code>data</code>变量现在是NumPy数组中定义的连续内存块的视图!为了显示这一点，我们将修改数组中的一个值……<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">4</span>] = <span class="number">555</span></span><br><span class="line">[d <span class="keyword">for</span> d <span class="keyword">in</span> data] <span class="comment"># [0, 1, 2, 3, 555, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></p>
<p>…观察数据视图也在变化。<code>x</code>和<code>data</code>都指向相同的连续内存块。</p>
<p>通过比较Python列表和NumPy ndarray的内部结构，很明显，NumPy的数组对于表示相同类型数据的列表来说要<strong>简单得多</strong>。这一事实与使编译器能够更有效地处理有关。</p>
<h2 id="Just-for-fun-a-few-“never-use-these”-hacks¶"><a href="#Just-for-fun-a-few-“never-use-these”-hacks¶" class="headerlink" title="Just for fun: a few “never use these” hacks¶"></a>Just for fun: a few “never use these” hacks<a href="#Just-for-fun:-a-few-&quot;never-use-these&quot;-hacks">¶</a></h2><p>使用“ctype”将c级数据封装在Python对象后面，可以做一些非常有趣的事情。如果我的朋友詹姆斯·鲍威尔(James Powell)说得对，我会在这里说:<a href="http://seriously.dontusethiscode.com/" target="_blank" rel="noopener">说真的，不要使用这段代码</a>。虽然下面的内容实际上不应该使用(曾经使用过)，但我仍然觉得非常有趣!</p>
<h3 id="Modifying-the-Value-of-an-Integer¶"><a href="#Modifying-the-Value-of-an-Integer¶" class="headerlink" title="Modifying the Value of an Integer¶"></a>Modifying the Value of an Integer<a href="#Modifying-the-Value-of-an-Integer">¶</a></h3><p>受到<a href="http://www.reddit.com/r/Python/comments/2441cv/can_you_change_the_value_of_1/" target="_blank" rel="noopener">Reddit文章</a>的启发，我们实际上可以修改整型对象的数值!如果我们使用“0”或“1”这样的公共数字，很可能会导致Python内核崩溃。但如果我们用不太重要的数字来做，我们就能侥幸过关，至少是短暂的。</p>
<p>注意，这是一个非常非常糟糕的想法。特别是，如果您在IPython笔记本上运行这个程序，您可能会破坏IPython内核的运行能力(因为您在其运行时处理变量)。不过，我们还是祈祷一下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WARNNG: never do this!</span></span><br><span class="line">id113 = id(<span class="number">113</span>)</span><br><span class="line">iptr = IntStruct.from_address(id113)</span><br><span class="line">iptr.ob_digit = <span class="number">4</span>  <span class="comment"># now Python's 113 contains a 4!</span></span><br><span class="line"></span><br><span class="line"><span class="number">113</span> == <span class="number">4</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>但是请注意，现在我们不能以简单的方式设置值，因为在Python中不再存在真正的值“113”!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">113</span> <span class="comment"># 4</span></span><br><span class="line"><span class="number">112</span> + <span class="number">1</span> <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">恢复的一种方法是直接操作字节。我们知道$$$<span class="number">113</span> = <span class="number">7</span> \times <span class="number">16</span>^<span class="number">1</span> + <span class="number">1</span> * <span class="number">16</span>^<span class="number">0</span>$$$,所以在低位优先的<span class="number">64</span>位系统上运行Python <span class="number">3.4</span>,运行以下代码:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">ctypes.cast(id113, ctypes.POINTER(ctypes.c_char))[<span class="number">3</span> * <span class="number">8</span>] = <span class="string">b'\x71'</span></span><br><span class="line"><span class="number">112</span> + <span class="number">1</span> <span class="comment"># 113</span></span><br></pre></td></tr></table></figure>
<p>然后我们恢复了！</p>
<p>再次强调一边:<strong>永远不要这样做</strong>。</p>
<h3 id="In-place-Modification-of-List-Contents¶"><a href="#In-place-Modification-of-List-Contents¶" class="headerlink" title="In-place Modification of List Contents¶"></a>In-place Modification of List Contents<a href="#In-place-Modification-of-List-Contents">¶</a></h3><p>上面我们对numpy数组中的值进行了就地修改。这很简单，因为numpy数组只是一个数据缓冲区。但是我们是否可以对列表做同样的事情呢?这有点棘手，因为列表存储<em>references</em>为值，而不是值本身。而且，为了不使Python本身崩溃，您需要非常小心地跟踪这些引用计数。以下是如何做到这一点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WARNING: never do this!</span></span><br><span class="line">L = [<span class="number">42</span>]</span><br><span class="line">Lwrapper = ListStruct.from_address(id(L))</span><br><span class="line">item_address = ctypes.c_long.from_address(Lwrapper.ob_item)</span><br><span class="line">print(<span class="string">"before:"</span>, L) <span class="comment"># before: [42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># change the c-pointer of the list item</span></span><br><span class="line">item_address.value = id(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we need to update reference counts by hand</span></span><br><span class="line">IntStruct.from_address(id(<span class="number">42</span>)).ob_refcnt -= <span class="number">1</span></span><br><span class="line">IntStruct.from_address(id(<span class="number">6</span>)).ob_refcnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"after: "</span>, L) <span class="comment"># after:  [6]</span></span><br></pre></td></tr></table></figure>
<p>就像我说的，你不应该用这个，我真的想不出你为什么要用这个。但是它可以让您了解解释器在修改列表内容时必须执行的操作类型。将它与上面的NumPy示例进行比较，您将看到Python列表比Python数组有更多开销的一个原因。</p>
<h3 id="Meta-Goes-Meta-a-self-wrapping-Python-object¶"><a href="#Meta-Goes-Meta-a-self-wrapping-Python-object¶" class="headerlink" title="Meta Goes Meta: a self-wrapping Python object¶"></a>Meta Goes Meta: a self-wrapping Python object<a href="#Meta-Goes-Meta:-a-self-wrapping-Python-object">¶</a></h3><p>使用上述方法，我们可以开始变得更奇怪。<code>ctypes</code>中的<code>Structure</code>类本身就是一个Python对象，可以在<a href="https://hg.python.org/cpython/file/3.4/Modules/_ctypes/ctypes.h#l46" target="_blank" rel="noopener">Modules/_ctypes/ctypes.h</a>中看到。就像我们对int和list进行封装一样，我们也可以对结构本身进行封装，如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStructStruct</span><span class="params">(ctypes.Structure)</span>:</span></span><br><span class="line">    _fields_ = [(<span class="string">"ob_refcnt"</span>, ctypes.c_long),</span><br><span class="line">                (<span class="string">"ob_type"</span>, ctypes.c_void_p),</span><br><span class="line">                (<span class="string">"ob_ptr"</span>, ctypes.c_long),  <span class="comment"># char* pointer cast to long</span></span><br><span class="line">                    ]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"CStructStruct(ptr=0x&#123;self.ob_ptr:x&#125;, "</span></span><br><span class="line">                <span class="string">"refcnt=&#123;self.ob_refcnt&#125;)"</span>).format(self=self)</span><br></pre></td></tr></table></figure>
<p>现在我们将尝试创建一个封装自身的结构。我们不能直接这样做，因为我们不知道在内存中会创建什么地址。但是我们可以做的是创建一个<em>second</em>结构包装第一个，并使用它来修改它的内容。</p>
<p>我们先做一个临时的元结构，然后包装它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmp = IntStruct.from_address(id(<span class="number">0</span>))</span><br><span class="line">meta = CStructStruct.from_address(id(tmp))</span><br><span class="line"></span><br><span class="line">print(repr(meta))</span><br><span class="line"></span><br><span class="line">CStructStruct(ptr=<span class="number">0x10023ef00</span>, refcnt=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们添加第三个结构，并使用它来就地修改第二个的内存值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meta_wrapper = CStructStruct.from_address(id(meta))</span><br><span class="line">meta_wrapper.ob_ptr = id(meta)</span><br><span class="line"></span><br><span class="line">print(meta.ob_ptr == id(meta)) <span class="comment"># True</span></span><br><span class="line">print(repr(meta)) <span class="comment"># CStructStruct(ptr=0x106d828c8, refcnt=7)</span></span><br></pre></td></tr></table></figure>
<p>我们现在有了一个自封装的Python结构!</p>
<p>再说一遍，我想不出你为什么要这么做。请记住，在Python中，这种类型的自我引用是具有开创性的——由于它的动态类型，在不直接入侵内存的情况下，这样做是非常直接的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">L.append(L)</span><br><span class="line">print(L) <span class="comment"># [[...]]</span></span><br></pre></td></tr></table></figure>
<h2 id="Conclusion¶"><a href="#Conclusion¶" class="headerlink" title="Conclusion¶"></a>Conclusion<a href="#Conclusion">¶</a></h2><p>Python是缓慢的。正如我们所看到的，这其中的一个重要原因是引擎盖下的间接类型，它使Python变得快速、简单、有趣。正如我们所看到的，Python本身提供了可以用来攻击Python对象本身的工具。</p>
<p>我希望通过对不同对象之间的差异的探索，以及对CPython本身内部的一些自由主义的胡乱操作，可以使这一点更加清晰。这个练习对我非常有启发，我希望对你也一样……黑客快乐!</p>
<p>这篇博文完全是在IPython笔记本上写的。完整的笔记本可以在这里<a href="http://jakevdp.github.io/downloads/notebooks/WhyPythonIsSlow.ipynb" target="_blank" rel="noopener">下载</a>，或者静态地在这里<a href="http://nbviewer.ipython.org/url/jakevdp.github.io/downloads/notebooks/WhyPythonIsSlow.ipynb" target="_blank" rel="noopener">查看</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://protao.github.io/2018/06/30/Python-2018-06-30-WhyPythonisSlow/" data-id="cjxo5e6px0034z16d1brgm2nh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/translation/">translation</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="../C-2018-06-30-Counting-Objects-in-CPP/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          【译】Counting Objects in C++
        
      </div>
    </a>
  
  
    <a href="../../29/程序员的玩具-2018-06-29-LC-Tree/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">LeetCode刷题笔记——Tree</div>
    </a>
  
</nav>

  
</article>




</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../../../../categories/C/">C++</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/python/">python</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/信息安全/">信息安全</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/大数据/">大数据</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/数学/">数学</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/机器学习/">机器学习</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/生活/">生活</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/程序员的玩具/">程序员的玩具</a><span class="category-list-count">38</span></li><li class="category-list-item"><a class="category-list-link" href="../../../../categories/读书笔记/">读书笔记</a><span class="category-list-count">7</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/C/">C++</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/algorithm/">algorithm</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/bigdata/">bigdata</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/database/">database</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/dataprocessing/">dataprocessing</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/deeplearning/">deeplearning</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/financing/">financing</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/generative/">generative</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/hadoop/">hadoop</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/hash/">hash</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/hbase/">hbase</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/linux/">linux</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/machinelearning/">machinelearning</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/maths/">maths</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/model/">model</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/nlp/">nlp</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/numpy/">numpy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/python/">python</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/reading/">reading</a><span class="tag-list-count">38</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/scala/">scala</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/security/">security</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/shell/">shell</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/spark/">spark</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/spider/">spider</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/tools/">tools</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/translation/">translation</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/trick/">trick</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/web/">web</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="../../../../tags/C/" style="font-size: 17.69px;">C++</a> <a href="../../../../tags/algorithm/" style="font-size: 19.23px;">algorithm</a> <a href="../../../../tags/bigdata/" style="font-size: 15.38px;">bigdata</a> <a href="../../../../tags/database/" style="font-size: 10px;">database</a> <a href="../../../../tags/dataprocessing/" style="font-size: 12.31px;">dataprocessing</a> <a href="../../../../tags/deeplearning/" style="font-size: 13.85px;">deeplearning</a> <a href="../../../../tags/financing/" style="font-size: 11.54px;">financing</a> <a href="../../../../tags/generative/" style="font-size: 12.31px;">generative</a> <a href="../../../../tags/hadoop/" style="font-size: 12.31px;">hadoop</a> <a href="../../../../tags/hash/" style="font-size: 12.31px;">hash</a> <a href="../../../../tags/hbase/" style="font-size: 10px;">hbase</a> <a href="../../../../tags/linux/" style="font-size: 13.85px;">linux</a> <a href="../../../../tags/machinelearning/" style="font-size: 16.92px;">machinelearning</a> <a href="../../../../tags/maths/" style="font-size: 16.15px;">maths</a> <a href="../../../../tags/model/" style="font-size: 11.54px;">model</a> <a href="../../../../tags/mysql/" style="font-size: 10px;">mysql</a> <a href="../../../../tags/nlp/" style="font-size: 14.62px;">nlp</a> <a href="../../../../tags/numpy/" style="font-size: 10px;">numpy</a> <a href="../../../../tags/python/" style="font-size: 18.46px;">python</a> <a href="../../../../tags/reading/" style="font-size: 20px;">reading</a> <a href="../../../../tags/scala/" style="font-size: 10px;">scala</a> <a href="../../../../tags/security/" style="font-size: 13.85px;">security</a> <a href="../../../../tags/shell/" style="font-size: 13.08px;">shell</a> <a href="../../../../tags/spark/" style="font-size: 10.77px;">spark</a> <a href="../../../../tags/spider/" style="font-size: 10px;">spider</a> <a href="../../../../tags/tools/" style="font-size: 17.69px;">tools</a> <a href="../../../../tags/translation/" style="font-size: 10.77px;">translation</a> <a href="../../../../tags/trick/" style="font-size: 12.31px;">trick</a> <a href="../../../../tags/web/" style="font-size: 11.54px;">web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/05/">五月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/04/">四月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/03/">三月 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/02/">二月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2019/01/">一月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/12/">十二月 2018</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/11/">十一月 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/10/">十月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/09/">九月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/08/">八月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/06/">六月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/05/">五月 2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/04/">四月 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/03/">三月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2018/01/">一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/11/">十一月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/10/">十月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/08/">八月 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/07/">七月 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/06/">六月 2017</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/05/">五月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2017/03/">三月 2017</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../../../2019/06/17/生活-2019-06-17-GTD/">《搞定I——无压工作的艺术》</a>
          </li>
        
          <li>
            <a href="../../../../2019/05/26/C-2019-05-26-Effective-CPP-IV/">《Effective C++》第四部分：设计和声明</a>
          </li>
        
          <li>
            <a href="../../../../2019/05/17/C-2019-05-17-Effective-CPP-III/">《Effective C++》第三部分：资源管理</a>
          </li>
        
          <li>
            <a href="../../../../2019/05/10/机器学习-2019-05-10-alchemy-trick/">仓鼠一般搜集到的炼丹技巧</a>
          </li>
        
          <li>
            <a href="../../../../2019/05/08/Python-2019-05-08-SICP2/">Python中使用函数构建对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  


  </span>
</aside>

        
      </div>
      <footer id="footer">

<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>

  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Yongtao Zhang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="../../../../index.html" class="mobile-nav-link">home</a>
  
    <a href="../../../../archives" class="mobile-nav-link">archives</a>
  
    <a href="../../../../about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">
  <script src="../../../../fancybox/jquery.fancybox.pack.js"></script>


<script src="../../../../js/script.js"></script>



  </div>
</body>
</html>